<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PACE – Production Analysis & Capacity Explorer</title>
  <style>
    :root{
      --pri-blue:#25408F; --pri-green:#92D050;
      --bg:#E9EDF5; --card:#FBFCFE; --ink:#0F172A; --muted:#475569; --border:#D7E0F3;

      /* overridden by /api/settings/kpi-theme at runtime */
      --good-bg:#dcfce7;  --good-fg:#065f46;
      --warn-bg:#fef9c3;  --warn-fg:#7c5e10;
      --bad-bg:#fee2e2;   --bad-fg:#7f1d1d;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Arial,sans-serif}

    /* Header */
    .top-border{position:fixed;top:0;left:0;width:100%;height:96px;background:var(--pri-green);z-index:10;display:flex;align-items:center;padding:0 20px}
    .top-border .logo{height:72px}
    .top-title{font-size:28px;font-weight:900;margin-left:20px;color:#0A2A12}
    .tabs{margin-left:auto;display:flex;gap:8px}
    .tab{background:#ffffffd9;padding:8px 12px;border-radius:10px;text-decoration:none;color:#0A2A12;font-weight:700}
    .tab.active{background:#fff}

    .wrap{margin:120px 20px 40px 20px}
    .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin:0 0 16px}
    .meta-range{color:var(--muted);font-size:13px}
    .select{appearance:none;border:1px solid var(--border);background:#fff;border-radius:10px;padding:8px 12px;font-weight:600}

    /* Overall KPI tiles */
    .kpis{display:grid;grid-template-columns:repeat(auto-fit,minmax(170px,1fr));gap:10px;margin-top:6px}
    .tile{background:var(--card);padding:14px;border-radius:12px;box-shadow:0 2px 4px rgba(0,0,0,.08);border:1px solid var(--border);text-align:center;min-height:84px}
    .tile .lab{font-size:12px;color:#000;text-transform:uppercase;letter-spacing:.3px}
    .tile .val{font-size:22px;font-weight:900;margin-top:6px}
    .tile.good { background: var(--good-bg); color: var(--good-fg); }
    .tile.warn { background: var(--warn-bg); color: var(--warn-fg); }
    .tile.bad  { background: var(--bad-bg);  color: var(--bad-fg);  }

    .section-gap{margin-top:28px}

    .card{background:var(--card);border-radius:12px;border:1px solid var(--border);box-shadow:0 2px 6px rgba(0,0,0,.08);padding:12px}
    .card h3{margin:0 0 8px;font-size:18px;color:var(--pri-blue);display:flex;gap:8px;align-items:center}
    .card .sub{font-size:12px;color:var(--muted);font-weight:600}

    /* Line tiles */
    .line-tiles{display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:12px}
    .lt-card{background:#fff;border:1px solid var(--border);border-radius:12px;padding:12px;display:grid;grid-template-columns:1fr 140px;gap:10px;border-left-width:6px}
    .lt-card.good { border-left-color: var(--good-fg); }
    .lt-card.warn { border-left-color: var(--warn-fg); }
    .lt-card.bad  { border-left-color: var(--bad-fg); }
    .lt-head{display:flex;align-items:baseline;justify-content:space-between}
    .lt-name{font-weight:900}
    .lt-nameplate{font-size:12px;color:var(--muted)}
    .lt-badges{display:flex;gap:6px;margin-top:6px}
    .badge{padding:2px 8px;border-radius:999px;font-size:12px;font-weight:800;border:1px solid #0001}
    .badge.maint{background:#FEE8A6;color:#3B2F0A}
    .badge.prod {background:#DBE6FF;color:#0D246F}
    .lt-metrics{display:grid;grid-template-columns:repeat(2,1fr);gap:6px}
    .m{background:#f7fafc;border:1px solid var(--border);border-radius:10px;padding:8px;text-align:center}
    .m .lab{font-size:11px;color:var(--muted)}
    .m .val{font-weight:900}
    .m.good { background: var(--good-bg); }
    .m.warn { background: var(--warn-bg); }
    .m.bad  { background: var(--bad-bg);  }
    .lt-right{display:flex;flex-direction:column;gap:8px;align-items:center;justify-content:center}

    /* Gauges */
    .speedo{width:120px;height:78px}
    .gauge { background: transparent; }
    .gauge .track { stroke: #e5e7eb; }
    .gauge .pct { font-size: 18px; font-weight: 800; }
    .gauge.good .needle { stroke: var(--good-fg); }
    .gauge.warn .needle { stroke: var(--warn-fg); }
    .gauge.bad  .needle { stroke: var(--bad-fg); }
    .gauge .cap{font-size:11px;color:var(--muted);text-align:center;margin-top:-6px}
    .gauge .band { opacity:.25; stroke-width:10; fill:none }

    /* Tables / Heatmaps */
    table{width:100%;border-collapse:collapse;margin-top:6px}
    th,td{padding:8px;border-bottom:1px solid #E1E9F8;text-align:center}
    th{background:var(--pri-blue);color:#fff;font-size:13px;position:sticky;top:0}
    td.line{text-align:left;font-weight:700}
    #heat td.good, #heatFactors td.good { background: var(--good-bg); }
    #heat td.warn, #heatFactors td.warn { background: var(--warn-bg); }
    #heat td.bad,  #heatFactors td.bad  { background: var(--bad-bg); }

    /* Trend */
    .chart-section{margin-top:16px}
    .chart-container{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:10px}
    .chart{background:linear-gradient(180deg,#F7F9FF,#EEF3FF);border:1px solid var(--border);border-radius:10px;padding:6px}
    .chart svg{width:100%;height:260px;display:block}
  </style>
</head>
<body>
  <div class="top-border">
    <img src="img/pri-logo.png" alt="PRI Logo" class="logo" />
    <div class="top-title">PACE – Production Analysis & Capacity Explorer</div>
    <div class="tabs">
      <a class="tab" href="index.html">Work Orders</a>
      <a class="tab" href="pm.html">PM</a>
      <a class="tab" href="prodstatus.html">Prod Status</a>
      <a class="tab" href="kpi-by-asset.html">KPIs by Asset</a>
      <a class="tab active" href="#">Production</a>
      <a class="tab" href="admin">Admin</a>
    </div>
  </div>

  <div class="wrap">
    <div class="controls">
      <span class="meta-range">Timeframe:</span>
      <select id="tf" class="select">
        <option value="today">Today</option>
        <option value="yesterday">Yesterday</option>
        <option value="thisweek">This week (Mon–Sun)</option>
        <option value="lastweek">Last week (Mon–Sun)</option>
        <option value="thismonth">This month</option>
        <option value="lastmonth" selected>Last month</option>
        <option value="thisq">This quarter</option>
        <option value="lastq">Last quarter</option>
        <option value="thisyear">This year</option>
        <option value="lastyear">Last year</option>
        <option value="last7">Trailing 7 days</option>
        <option value="last30" >Trailing 30 days</option>
        <option value="last12m">Trailing 12 months</option> 
      </select>
      <span id="tfLabel" class="meta-range"></span>
    </div>

    <!-- OVERALL KPIs -->
    <section>
      <h2>Overall KPIs <span class="sub" id="rangeLabel"></span></h2>
      <div class="kpis">
        <div class="tile" id="tile-oee"><div class="lab">OEE</div><div class="val" id="ov-oee">--%</div></div>
        <div class="tile" id="tile-av"><div class="lab">Availability</div><div class="val" id="ov-av">--%</div></div>
        <div class="tile" id="tile-pr"><div class="lab">Performance (Raw 24h)</div><div class="val" id="ov-pr">--%</div></div>
        <div class="tile" id="tile-pa"><div class="lab">Performance (Adj for DT)</div><div class="val" id="ov-pa">--%</div></div>
        <div class="tile"><div class="lab">Total Pounds</div><div class="val" id="ov-lbs">--</div></div>
        <div class="tile"><div class="lab">Maint DT (h)</div><div class="val" id="ov-mdt">--</div></div>
        <div class="tile"><div class="lab">Prod DT (h)</div><div class="val" id="ov-pdt">--</div></div>
      </div>
    </section>

    <!-- HEATMAPS + LINE TILES -->
    <section class="section-gap">
      <div class="card">
        <h3>Weekday OEE Heatmap <span class="sub" id="hmLabel"></span></h3>
        <table id="heat"></table>
      </div>

      <div class="card" style="margin-top:14px">
        <h3>OEE Factors Heatmap (Availability / Performance-Adj / Quality) <span class="sub" id="hm2Label"></span></h3>
        <table id="heatFactors"></table>
      </div>

      <div class="card" style="margin-top:14px">
        <h3>Line Tiles <span class="sub" id="ltLabel"></span></h3>
        <div id="lineTiles" class="line-tiles"></div>
      </div>
    </section>

    <!-- TREND -->
    <section class="chart-section">
      <div class="chart-container">
        <h2>Production Trend <span class="sub" id="trLabel"></span></h2>
        <div class="chart"><div id="trendChart"></div></div>
      </div>
    </section>
  </div>
<script>
let MAPPINGS;
async function loadMappings(){
  try {
    MAPPINGS = await (await fetch(`mappings.json?ts=${Date.now()}`, {cache:'no-store'})).json();
  } catch {
    console.warn('mappings.json not found; using empty defaults');
    MAPPINGS = { capacities_lbs_hr:{}, capacity_by_material_lbs_hr:{}, capacity_aliases:{}, material_aliases:{} };
  }
}


// Resolve per-line capacity with material override, then DEFAULT, then global fallback
function capacityFor(lineName, material){
  const { 
    capacities_lbs_hr: caps = {}, 
    capacity_by_material_lbs_hr: byMat = {}, 
    capacity_aliases: alias = {}, 
    material_aliases: malias = {} 
  } = MAPPINGS || {};

  const canon = (caps[lineName] !== undefined || byMat[lineName])
    ? lineName
    : (alias[lineName] || lineName);

  const k = String(material ?? '').trim().toUpperCase();
  const m = malias[k] || (k === '' ? 'DEFAULT' : k);

  return byMat[canon]?.[m] ?? byMat[canon]?.DEFAULT ?? caps[canon] ?? 0;
}
</script>

  <!-- Theme loader -->
  <script>
    async function loadThemeAndApply() {
      try {
        const t = await fetch('/api/settings/kpi-theme').then(r=>r.json());
        const c = t?.colors || {};
        if (c.good?.bg)  document.documentElement.style.setProperty('--good-bg', c.good.bg);
        if (c.good?.fg)  document.documentElement.style.setProperty('--good-fg', c.good.fg);
        if (c.warn?.bg)  document.documentElement.style.setProperty('--warn-bg', c.warn.bg);
        if (c.warn?.fg)  document.documentElement.style.setProperty('--warn-fg', c.warn.fg);
        if (c.bad?.bg)   document.documentElement.style.setProperty('--bad-bg',  c.bad.bg);
        if (c.bad?.fg)   document.documentElement.style.setProperty('--bad-fg',  c.bad.fg);
      } catch {}
    }
  </script>

  <!-- App -->
  <script>
    // ---------- CONFIG / UTILS ----------
    const THRESH = {
      capacityAdj: { good: 0.80, warn: 0.60 },
      oee:         { good: 0.50, warn: 0.25 },
      availability:{ good: 0.80, warn: 0.60 }
    };
    const grade   = (v, {good, warn}) => (v >= good ? 'good' : v >= warn ? 'warn' : 'bad');
    const fmtPct  = v => (v == null ? '0%' : (v*100).toFixed(0) + '%');
    const fmtNum  = v => (v == null ? '0' : Number(v).toLocaleString());

    const _WDAYS = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
    function weekdayLocal(v) {
      if (!v) return null;
      if (v instanceof Date && !isNaN(v)) return _WDAYS[v.getDay()];
      if (typeof v === 'string') {
        const iso10 = v.slice(0,10);
        const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(iso10);
        if (m) { const dt = new Date(+m[1], +m[2]-1, +m[3]); return _WDAYS[dt.getDay()]; }
        const dt2 = new Date(v);
        if (!isNaN(dt2)) return _WDAYS[dt2.getDay()];
      }
      return null;
    }

    function isWeekday(d){ const n = d.getDay(); return n !== 0 && n !== 6; }
    function formatISO(d){ return new Date(d.getTime()-d.getTimezoneOffset()*60000).toISOString().slice(0,10); }

    function startOfWeek(d){ const x=new Date(d); const day=(x.getDay()+6)%7; x.setDate(x.getDate()-day); x.setHours(0,0,0,0); return x;}
    function endOfWeek(d){ const x=startOfWeek(d); x.setDate(x.getDate()+6); return x;}
    function startOfMonth(d){ return new Date(d.getFullYear(), d.getMonth(), 1); }
    function endOfMonth(d){ return new Date(d.getFullYear(), d.getMonth()+1, 0); }
    function startOfQuarter(d){ return new Date(d.getFullYear(), Math.floor(d.getMonth()/3)*3, 1); }
    function endOfQuarter(d){ const s=startOfQuarter(d); return new Date(s.getFullYear(), s.getMonth()+3, 0); }

    // Gauges
    function polarToCartesian(cx, cy, r, angDeg) {
      const a = angDeg * Math.PI / 180;
      return { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
    }
    function arcPath(cx, cy, r, startDeg, endDeg, sweepFlag) {
      const s = polarToCartesian(cx, cy, r, startDeg);
      const e = polarToCartesian(cx, cy, r, endDeg);
      const largeArc = Math.abs(endDeg - startDeg) > 180 ? 1 : 0;
      return `M ${s.x} ${s.y} A ${r} ${r} 0 ${largeArc} ${sweepFlag} ${e.x} ${e.y}`;
    }
    function gaugeSVG(pct, label, cls='') {
      const p = Math.max(0, Math.min(1, pct || 0));
      const R = 48, cx = 60, cy = 60;
      const track  = arcPath(cx, cy, R, 180, 360, 1);
      const band   = arcPath(cx, cy, R, 180, 180 + 180*Math.max(p,0.02), 1);
      const needle = arcPath(cx, cy, R, 180, 180 + 180*p, 1);
      const color = (cls==='good') ? 'var(--good-fg)' : (cls==='warn') ? 'var(--warn-fg)' : 'var(--bad-fg)';
      return `
        <div class="gauge ${cls}">
          <svg viewBox="0 0 120 80" xmlns="http://www.w3.org/2000/svg" class="speedo">
            <path d="${track}"  class="track"  fill="none" stroke-width="10"/>
            <path d="${band}"   class="band"   stroke="${color}" />
            <path d="${needle}" class="needle" fill="none" stroke="${color}" stroke-width="10" stroke-linecap="round"/>
            <text x="60" y="48" text-anchor="middle" class="pct">${Math.round(p*100)}%</text>
          </svg>
          <div class="cap">${label}</div>
        </div>`;
    }

    // ---------- CORE RENDER ----------
    async function renderForRange(fromISO, toISO, label){
      document.getElementById('rangeLabel').textContent = `(${label})`;
      document.getElementById('hmLabel').textContent    = label;
      document.getElementById('hm2Label').textContent   = label;
      document.getElementById('ltLabel').textContent    = label;
      document.getElementById('trLabel').textContent    = label;

      await loadThemeAndApply();

      // Build weekday list for planned hours calc
      const fromD = new Date(fromISO + 'T00:00:00');
      const toD   = new Date(toISO   + 'T00:00:00');
      const dates = [];
      for (let d = new Date(fromD); d <= toD; d.setDate(d.getDate()+1)) {
        if (isWeekday(d)) dates.push(formatISO(d));
      }
      const weekdaysCount = dates.length;

      // Fetch
      const [summaryRaw, bylineRaw] = await Promise.all([
        fetch(`/api/production/summary?from=${fromISO}&to=${toISO}`).then(r=>r.json()).catch(()=>null),
        fetch(`/api/production/by-line?from=${fromISO}&to=${toISO}`).then(r=>r.json()).catch(()=>[])
      ]);

      // Extruders only
      const byline = (bylineRaw || []).filter(r => r.machine && r.machine.startsWith('Extruder'));

      // ---------- Aggregate per line across range ----------
      const agg = {};
      for (const r of byline) {
        const m = r.machine;
        // Prefer server-enriched nameplate, but fall back to client-side resolver.
        // If you want to ALWAYS use the client resolver, just set cap = capacityFor(...).
        const cap = (r.nameplate_lbs_hr && r.nameplate_lbs_hr > 0)
          ? r.nameplate_lbs_hr
          : capacityFor(r.machine, r.material);

        const mh  = r.machine_hours || 0;       // prefer machine_hours from source if present
        const md  = r.maint_dt_h || 0;
        const pd  = r.prod_dt_h  || 0;

        if (!agg[m]) agg[m] = { lbs:0, cap:cap, maint:0, prod:0, mach:0, days:weekdaysCount };
        agg[m].lbs   += (r.pounds || 0);
        agg[m].maint += Math.max(0, md);
        agg[m].prod  += Math.max(0, pd);
        agg[m].mach  += Math.max(0, mh);
        if (cap > 0) agg[m].cap = cap;
      }

      const perLine = Object.keys(agg).sort().map(m => {
        const a = agg[m];
        const plannedH = 24 * a.days;
        const runtimeH = a.mach > 0 ? a.mach : (a.cap > 0 ? (a.lbs / a.cap) : 0);
        const maintH   = Math.max(0, a.maint);
        const prodH    = Math.max(0, a.prod);
        const effPlanH = Math.max(0, plannedH);
        const availDen = effPlanH;

        // Availability = runtime / planned
        const availability = availDen > 0 ? (runtimeH / availDen) : 0;

        // Performance Adj = lbs / ((planned - maint) * cap)
        const adjDen = Math.max(0, (effPlanH - maintH)) * a.cap;
        const perfAdj = adjDen > 0 ? (a.lbs / adjDen) : 0;

        // Performance Raw = lbs / (planned * cap)
        const rawDen = effPlanH * a.cap;
        const perfRaw = rawDen > 0 ? (a.lbs / rawDen) : 0;

        // OEE (server may provide r.oee; we compute anyway)
        const oee = availability * perfAdj;

        // Quality (inferred) = OEE / (Availability * PerformanceAdj), guard divide-by-zero
        const qual = (availability > 0 && perfAdj > 0) ? Math.max(0, Math.min(1, oee / (availability * perfAdj))) : 1;

        // Production downtime (what’s left after runtime + maint)
        const prodDT = Math.max(0, effPlanH - maintH - runtimeH);

        return {
          machine:m, cap:a.cap, lbs:a.lbs,
          maint:maintH, prod:prodDT, mach:a.mach,
          avail:availability, perfRaw, perfAdj, qual, oee
        };
      });

      // ---------- Overall tiles ----------
      const totalPlannedH = perLine.length * 24 * weekdaysCount;
      const totalRuntimeH = perLine.reduce((s,x)=>s + (x.mach>0 ? x.mach : (x.cap>0 ? x.lbs/x.cap : 0)), 0);
      const totalMaintH   = perLine.reduce((s,x)=>s + x.maint, 0);
      const totalProdH    = perLine.reduce((s,x)=>s + x.prod, 0);
      const totalLbs      = perLine.reduce((s,x)=>s + x.lbs, 0);
      const totalCap24    = perLine.reduce((s,x)=>s + (x.cap*24*weekdaysCount), 0);
      const totalAdjCap   = perLine.reduce((s,x)=>s + (x.cap*Math.max(0, 24*weekdaysCount - x.maint)), 0);

      const ovAvail   = totalPlannedH > 0 ? (totalRuntimeH/totalPlannedH) : 0;
      const ovPerfRaw = totalCap24 > 0   ? (totalLbs/totalCap24) : 0;
      const ovPerfAdj = totalAdjCap > 0  ? (totalLbs/totalAdjCap) : 0;
      const ovOEE     = ovAvail * ovPerfAdj;

      document.getElementById('ov-oee').textContent = (ovOEE*100).toFixed(0) + '%';
      document.getElementById('ov-av').textContent  = (ovAvail*100).toFixed(0) + '%';
      document.getElementById('ov-pr').textContent  = (ovPerfRaw*100).toFixed(0) + '%';
      document.getElementById('ov-pa').textContent  = (ovPerfAdj*100).toFixed(0) + '%';
      document.getElementById('ov-lbs').textContent = totalLbs.toLocaleString();
      document.getElementById('ov-mdt').textContent = totalMaintH.toFixed(1);
      document.getElementById('ov-pdt').textContent = totalProdH.toFixed(1);

      const setTileClass = (tileSel, v, thr) => {
        const tile = document.querySelector(tileSel);
        const cls = grade(v || 0, thr);
        tile.classList.remove('good','warn','bad'); tile.classList.add(cls);
      };
      setTileClass('#tile-oee', ovOEE, THRESH.oee);
      setTileClass('#tile-av',  ovAvail, THRESH.availability);
      setTileClass('#tile-pr',  ovPerfAdj, THRESH.capacityAdj); // show adj as “performance”
      setTileClass('#tile-pa',  ovPerfAdj, THRESH.capacityAdj);

      // ---------- Line tiles ----------
      const cont = document.getElementById('lineTiles'); cont.innerHTML = '';
      perLine.forEach(r => {
        const tileGrade = grade(r.oee, THRESH.oee);
        const rawGrade  = grade(r.perfRaw, THRESH.capacityAdj);
        const adjGrade  = grade(r.perfAdj, THRESH.capacityAdj);

        const el = document.createElement('div');
        el.className = `lt-card ${tileGrade}`;
        el.innerHTML = `
          <div>
            <div class="lt-head">
              <div class="lt-name">${r.machine}</div>
              const mat = r.material ?? 'DEFAULT';
              <div class="lt-nameplate">Nameplate ${r.cap?.toLocaleString()} lb/hr <span style="color:#64748b">(mat: ${mat})</span></div>
            </div>
            <div class="lt-badges">
              <span class="badge maint">Maint DT ${r.maint.toFixed(1)}h</span>
              <span class="badge prod">Prod DT ${r.prod.toFixed(1)}h</span>
            </div>
            <div class="lt-metrics" style="margin-top:6px">
              <div class="m"><div class="lab">OEE</div><div class="val">${(r.oee*100).toFixed(0)}%</div></div>
              <div class="m"><div class="lab">Availability</div><div class="val">${(r.avail*100).toFixed(0)}%</div></div>
              <div class="m"><div class="lab">Perf Raw</div><div class="val">${(r.perfRaw*100).toFixed(0)}%</div></div>
              <div class="m"><div class="lab">Perf Adj</div><div class="val">${(r.perfAdj*100).toFixed(0)}%</div></div>
              <div class="m"><div class="lab">Quality*</div><div class="val">${(r.qual*100).toFixed(0)}%</div></div>
              <div class="m"><div class="lab">Pounds</div><div class="val">${r.lbs.toLocaleString()}</div></div>
            </div>
          </div>
          <div class="lt-right">
            ${gaugeSVG(r.perfRaw, 'Raw 24h', rawGrade)}
            ${gaugeSVG(r.perfAdj, 'Adj for DT', adjGrade)}
          </div>`;
        cont.appendChild(el);
      });

      // ---------- Heatmap 1: OEE ----------
      (function renderHeatmapOEE(){
        const table = document.getElementById('heat');
        // If short range (<=20 days), render per-date columns; else weekday averages
        const tDays = (new Date(toISO) - new Date(fromISO)) / 86400000 + 1;
        if (tDays <= 20) {
          const datesAll = [];
          for (let d = new Date(fromISO); d <= new Date(toISO); d.setDate(d.getDate()+1)) {
            if (isWeekday(d)) datesAll.push(formatISO(d));
          }
          const map = new Map(); // machine -> date -> oee
          for (const r of (byline || [])) {
            const key = r.machine; const d = (r.src_date||'').slice(0,10);
            if (!datesAll.includes(d)) continue;
            if (!map.has(key)) map.set(key, new Map());
            const availability = r.availability ?? 0;
            const perfAdj      = r.perf_adj ?? 0;
            const oee          = (r.oee ?? (availability * perfAdj)) || 0;
            const cur = map.get(key).get(d);
            map.get(key).set(d, cur==null ? oee : (cur+oee)/2);
          }
          let html = '<thead><tr><th>Line</th>'+datesAll.map(d=>`<th>${d.slice(5)}</th>`).join('')+'</tr></thead><tbody>';
          for (const m of [...map.keys()].sort()) {
            html += `<tr><td class="line">${m}</td>`;
            const row = map.get(m);
            for (const d of datesAll) {
              const v = row.get(d) || 0;
              const cls = grade(v, THRESH.oee);
              html += `<td class="${cls}">${Math.round(v*100)}%</td>`;
            }
            html += '</tr>';
          }
          html += '</tbody>';
          table.innerHTML = html;
          document.getElementById('hmLabel').textContent = `${label} (per-date)`;
        } else {
          const days = ['Mon','Tue','Wed','Thu','Fri'];
          const byLineDay = {};
          for (const r of (byline || [])) {
            const wd = weekdayLocal(r.src_date);
            if (!wd || wd==='Sat' || wd==='Sun') continue;
            const m = r.machine;
            byLineDay[m] ??= {Mon:{sum:0,n:0}, Tue:{sum:0,n:0}, Wed:{sum:0,n:0}, Thu:{sum:0,n:0}, Fri:{sum:0,n:0}};
            const availability = r.availability ?? 0;
            const perfAdj      = r.perf_adj ?? 0;
            const oee          = (r.oee ?? (availability * perfAdj)) || 0;
            byLineDay[m][wd].sum += oee;
            byLineDay[m][wd].n   += 1;
          }
          const machines = Object.keys(byLineDay).sort();
          let html = '<thead><tr><th>Line</th>'+days.map(d=>`<th>${d}</th>`).join('')+'</tr></thead><tbody>';
          for (const m of machines) {
            html += `<tr><td class="line">${m}</td>`;
            for (const d of days) {
              const agg = byLineDay[m][d] || {sum:0,n:0};
              const v = agg.n ? (agg.sum/agg.n) : 0;
              const cls = grade(v, THRESH.oee);
              html += `<td class="${cls}">${Math.round(v*100)}%</td>`;
            }
            html += '</tr>';
          }
          html += '</tbody>';
          table.innerHTML = html;
          document.getElementById('hmLabel').textContent = `${label} (weekday averages)`;
        }
      })();

      // ---------- Heatmap 2: Factors (Availability / Performance-Adj / Quality) ----------
      (function renderHeatmapFactors(){
        const days = ['Mon','Tue','Wed','Thu','Fri'];
        const table = document.getElementById('heatFactors');
      
        // Aggregate by line x weekday for each factor
        const aggBy = {}; // { [machine]: { [weekday]: { av:{sum,n}, pa:{sum,n}, q:{sum,n} } } }
        for (const r of (byline || [])) {
          const wd = weekdayLocal(r.src_date);
          if (!wd || wd==='Sat' || wd==='Sun') continue;
      
          const m = r.machine;
          const availability = (r.availability ?? 0);
          const perfAdj      = (r.perf_adj ?? 0);
          const oee          = (r.oee ?? (availability * perfAdj)) || 0;
          const qual         = (availability > 0 && perfAdj > 0)
            ? Math.max(0, Math.min(1, oee / (availability * perfAdj)))
            : 1;
      
          aggBy[m] ??= {};
          aggBy[m][wd] ??= { av:{sum:0,n:0}, pa:{sum:0,n:0}, q:{sum:0,n:0} };
          aggBy[m][wd].av.sum += availability; aggBy[m][wd].av.n += 1;
          aggBy[m][wd].pa.sum += perfAdj;      aggBy[m][wd].pa.n += 1;
          aggBy[m][wd].q.sum  += qual;         aggBy[m][wd].q.n  += 1;
        }
      
        // Two-row header: weekdays (colspan=3) then Avail/PerfAdj/Qual under each
        let thead =
          '<thead>' +
            '<tr><th rowspan="2">Line / Factor</th>' +
              days.map(d => `<th colspan="3">${d}</th>`).join('') +
            '</tr>' +
            '<tr>' +
              days.map(() => '<th>Avail</th><th>Perf-Adj</th><th>Qual*</th>').join('') +
            '</tr>' +
          '</thead>';
      
        const machines = Object.keys(aggBy).sort();
      
        const tdFor = (row, d, key, thr) => {
          const cell = row[d]?.[key];
          const v = cell && cell.n ? (cell.sum / cell.n) : 0;
          const cls = grade(v, thr);
          return `<td class="${cls}">${Math.round(v*100)}%</td>`;
        };
      
        let tbody = '<tbody>';
        for (const m of machines) {
          const row = aggBy[m];
          tbody += `<tr><td class="line">${m}</td>`;
          for (const d of days) {
            tbody += tdFor(row, d, 'av', THRESH.availability);
            tbody += tdFor(row, d, 'pa', THRESH.capacityAdj);
            // Using OEE thresholds for Quality; tune if you want a stricter bar.
            tbody += tdFor(row, d, 'q',  THRESH.oee);
          }
          tbody += '</tr>';
        }
        tbody += '</tbody>';
      
        table.innerHTML = thead + tbody;
        document.getElementById('hm2Label').textContent = `${document.getElementById('hmLabel').textContent.replace(/\s*\(.*\)$/, '')} (weekday averages)`;
      })();

      // ---------- Trend ----------
      (function renderTrend(){
        const byDate = new Map(); // d -> { lbs, nameplate, adjcap }
        for (let d = new Date(fromISO); d <= new Date(toISO); d.setDate(d.getDate()+1)) {
          if (isWeekday(d)) byDate.set(formatISO(d), { lbs:0, nameplate:0, adjcap:0 });
        }
        for (const r of byline) {
          const d = (r.src_date||'').slice(0,10); if (!byDate.has(d)) continue;
          // Prefer server-enriched nameplate, but fall back to client-side resolver.
          // If you want to ALWAYS use the client resolver, just set cap = capacityFor(...).
          const cap = (r.nameplate_lbs_hr && r.nameplate_lbs_hr > 0)
            ? r.nameplate_lbs_hr
            : capacityFor(r.machine, r.material);

          const lbs = r.pounds || 0;
          const dt  = (r.maint_dt_h||0)+(r.prod_dt_h||0);
          const row = byDate.get(d);
          row.lbs      += lbs;
          row.nameplate+= cap*24;
          row.adjcap   += cap*Math.max(0, 24 - dt);
        }
        const dates = [...byDate.keys()].sort();
        const pts = dates.map(d => {
          const p = byDate.get(d);
          return {
            rawU: p.nameplate>0 ? (p.lbs/p.nameplate) : 0,
            adjU: p.adjcap>0    ? (p.lbs/p.adjcap)    : 0
          };
        });
        let maxU = Math.max(0.1, ...pts.map(p => Math.max(p.rawU, p.adjU)));
        maxU = Math.min(Math.max(maxU*1.15, 0.3), 1.2);

        const w=900,h=260,padL=50,padB=30,ch=h-padB-40;
        const sx=i => padL + (i/Math.max(1,pts.length-1))*(w-padL-20);
        const sy=v => 30 + ch - (Math.min(v,1.2)/maxU)*ch;
        const toLine = arr => arr.map((p,i)=>`${sx(i)},${sy(p)}`).join(' ');

        const rawPts = toLine(pts.map(p=>p.rawU));
        const adjPts = toLine(pts.map(p=>p.adjU));

        const css = getComputedStyle(document.documentElement);
        const good = css.getPropertyValue('--good-fg').trim() || '#22c55e';
        const warn = css.getPropertyValue('--warn-fg').trim() || '#f59e0b';

        let grid=''; for(let i=0;i<=4;i++){ const y=30+(i/4)*ch;
          const val = (maxU*i/4)*100;
          grid += `<line x1="${padL}" y1="${y}" x2="${w-20}" y2="${y}" stroke="#D7E0F3" stroke-width="1" opacity="0.7"/>` +
                  `<text x="${w-18}" y="${y-4}" fill="#64748b" font-size="11">${val.toFixed(0)}%</text>`;
        }
        const xlabels = dates.map((d,i)=>`<text x="${sx(i)}" y="${h-10}" text-anchor="middle" fill="#475569" font-size="12">${d.slice(5)}</text>`).join('');

        const svg = `<svg viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg">
          <rect x="0" y="0" width="100%" height="100%" fill="#F7F9FF"/>
          ${grid}
          <polyline fill="none" stroke="${warn}" stroke-width="3" points="${adjPts}"/>
          <polyline fill="none" stroke="#2563eb" stroke-width="3" points="${rawPts}"/>
          ${xlabels}
        </svg>`;
        document.getElementById('trendChart').innerHTML = svg;
      })();
    }

    // ---------- RANGE PICKER ----------
    function computeRange(sel){
      const now = new Date(); now.setHours(0,0,0,0);
      const y = new Date(now); y.setDate(y.getDate()-1);
      const fmt = d => new Date(d.getTime()-d.getTimezoneOffset()*60000).toISOString().slice(0,10);

      const thisW = {from:startOfWeek(now), to:endOfWeek(now)};
      const lastW = {from:new Date(startOfWeek(now)), to:new Date(endOfWeek(now))}; lastW.from.setDate(lastW.from.getDate()-7); lastW.to.setDate(lastW.to.getDate()-7);
      const thisM = {from:startOfMonth(now), to:endOfMonth(now)};
      const lastM = {from:startOfMonth(new Date(now.getFullYear(), now.getMonth()-1, 1)), to:endOfMonth(new Date(now.getFullYear(), now.getMonth()-1, 1))};
      const thisQ = {from:startOfQuarter(now), to:endOfQuarter(now)};
      const lastQ = {from:startOfQuarter(new Date(now.getFullYear(), now.getMonth()-3, 1)), to:endOfQuarter(new Date(now.getFullYear(), now.getMonth()-3, 1))};
      const thisY = {from:new Date(now.getFullYear(),0,1), to:new Date(now.getFullYear(),11,31)};
      const lastY = {from:new Date(now.getFullYear()-1,0,1), to:new Date(now.getFullYear()-1,11,31)};

      switch(sel){
        case 'today':     return {from:fmt(now), to:fmt(now), label:'Today'};
        case 'yesterday': return {from:fmt(y),   to:fmt(y),   label:'Yesterday'};
        case 'thisweek':  return {from:fmt(thisW.from), to:fmt(thisW.to), label:'This week (Mon–Sun)'};
        case 'lastweek':  return {from:fmt(lastW.from), to:fmt(lastW.to), label:'Last week (Mon–Sun)'};
        case 'thismonth': return {from:fmt(thisM.from), to:fmt(thisM.to), label:'This month'};
        case 'lastmonth': return {from:fmt(lastM.from), to:fmt(lastM.to), label:'Last month'};
        case 'thisq':     return {from:fmt(thisQ.from), to:fmt(thisQ.to), label:'This quarter'};
        case 'lastq':     return {from:fmt(lastQ.from), to:fmt(lastQ.to), label:'Last quarter'};
        case 'thisyear':  return {from:fmt(thisY.from), to:fmt(thisY.to), label:'This year'};
        case 'lastyear':  return {from:fmt(lastY.from), to:fmt(lastY.to), label:'Last year'};
        case 'last7':     { const s=new Date(now); s.setDate(s.getDate()-6); return {from:fmt(s), to:fmt(now), label:'Trailing 7 days'}; }
        case 'last12m':   { const s=new Date(now); s.setMonth(s.getMonth()-12); return {from:fmt(s), to:fmt(now), label:'Trailing 12 months'}; }
        case 'last30':
        default:          { const s=new Date(now); s.setDate(s.getDate()-29); return {from:fmt(s), to:fmt(now), label:'Trailing 30 days'}; }
      }
    }

    (async function init(){
      const sel = document.getElementById('tf');
      async function go(){
        const r = computeRange(sel.value);
        document.getElementById('tfLabel').textContent = `${r.from} → ${r.to}`;
        await renderForRange(r.from, r.to, r.label);
      }
      // NEW: load mappings first
      await loadMappings();
      
      sel.addEventListener('change', go);
      await go();
    })();
  </script>
</body>
</html>
