<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PRI Pulse</title>
  <style>
    :root{
      --pri-blue:#25408F; --pri-green:#92D050;
      --bg:#E9EDF5; --card:#FBFCFE; --ink:#0F172A; --muted:#475569; --border:#D7E0F3;
      --good-bg:#dcfce7;  --good-fg:#10B981;
      --warn-bg:#fef9c3;  --warn-fg:#7c5e10;
      --bad-bg:#fee2e2;   --bad-fg:#7f1d1d;
      --shadow: 0 10px 25px rgba(0,0,0,.08);
      --chip:#f7fafc;

      /* sizing */
      --tile-head-fs: 30px;    /* ⬆ from 26px */
      --rank-fs: 20px;         /* ⬆ from 18px */
      --status-fs: 20px;       /* ⬆ from 18px */
    }
    *{box-sizing:border-box}

    /* ====== Global readability boost ====== */
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;font-weight:800;font-size:18px}
    .page-production::before{
      content:"";position:fixed;inset:0;z-index:-1;
      background:
        linear-gradient(to bottom, rgba(255,255,255,.75), rgba(255,255,255,.85)),
        url('img/PRIfront.png') center/cover no-repeat fixed;
    }

    .top-border{position:fixed;top:0;left:0;width:100%;height:96px;background:var(--pri-green);z-index:10;display:flex;align-items:center;padding:0 20px}
    .top-border .logo{height:72px}
    .top-title{font-size:38px;font-weight:900;margin-left:20px;color:#0A2A12}
    .tabs{margin-left:auto;display:flex;gap:8px;align-items:center}
    .tab{background:#ffffffd9;padding:8px 12px;border-radius:10px;text-decoration:none;color:#0A2A12;font-weight:800}
    .tab.active{background:#fff}
    .wrap{margin:120px 20px 40px 20px}

    #loading{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(255,255,255,.55);z-index:9999}
    #loading .spinner{width:64px;height:64px;border:8px solid #e5e7eb;border-top-color:var(--pri-blue);border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    .app{max-width:1920px;margin:0 auto}
    .toolbar{display:flex;justify-content:space-between;align-items:center;margin:10px 0 16px;gap:10px;flex-wrap:wrap}
    .left,.right{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .segBig{display:inline-flex;border:1px solid var(--border);border-radius:12px;overflow:hidden;background:var(--card);box-shadow:var(--shadow)}
    .segBig button{border:0;background:transparent;padding:10px 14px;font-weight:900;color:var(--muted);cursor:pointer;font-size:18px}
    .segBig button.active{background:var(--pri-blue);color:white}
    .pill{padding:8px 12px;border-radius:999px;background:white;border:1px solid var(--border);color:var(--muted);font-weight:900;font-size:16px}

    /* ====== KPI Strip ====== */
    .kpis{display:grid;grid-template-columns:repeat(6,1fr);gap:12px;margin-bottom:12px}
    .kpi{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:16px 18px;box-shadow:var(--shadow);min-height:100px}
    .kpi .label{font-size:20px;color:var(--muted);font-weight:900;text-transform:uppercase;letter-spacing:.6px}
    .kpi .value{font-size:40px;font-weight:900;margin-top:8px}
    .kpi.good{background:var(--good-bg);color:var(--good-fg);border-color:#bbf7d0}
    .kpi.warn{background:var(--warn-bg);color:var(--warn-fg);border-color:#fde68a}
    /* Red tile contrast fix */
    .kpi.bad{ background: var(--bad-bg); color:#fff; border-color:#fecaca }
    .kpi.bad .label, .kpi.bad .value{ color:#fff !important }

    .statusbar{display:flex;gap:10px;overflow:auto;padding:8px 2px;margin-bottom:14px}
    .chip{display:flex;align-items:center;gap:8px;padding:10px 12px;border:1px solid var(--border);border-radius:999px;background:var(--chip);white-space:nowrap;font-weight:900}
    .dot{width:12px;height:12px;border-radius:50%}
    .st-available{background:#16a34a}
    .st-setup{background:#f59e0b}
    .st-downm{background:#ef4444}
    .st-downp{background:#dc2626}

    .grid{display:grid;grid-template-columns:420px 1fr;gap:16px;align-items:stretch}
    
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;box-shadow:var(--shadow)}
    .card h3{margin:0;padding:12px 14px;border-bottom:1px solid var(--border);font-size:var(--tile-head-fs);letter-spacing:.3px;color:var(--muted);font-weight:900}
    .card .content{padding:16px}
    /* Wider left column just for the donuts card */
    /* Make left column wider so three donut rows have room */
    .gridWide{ grid-template-columns: 860px 1fr; }
    @media (max-width: 1500px){ .gridWide{ grid-template-columns: 700px 1fr; } }
    @media (max-width: 1200px){ .gridWide{ grid-template-columns: 1fr; } }
     
    /* avoid clipping */
    .card .content{ overflow: hidden; }

    .lines{display:grid;grid-template-columns:repeat(auto-fit,minmax(520px,1fr));gap:12px}
    .line{border:1px solid var(--border);border-radius:14px;padding:14px;background:white;display:flex;flex-direction:column}
    .lineheader{display:flex;justify-content:space-between;align-items:center}
    .linename{font-weight:900;font-size:20px}
    .badge{font-size:26px;font-weight:900;padding:6px 10px;border-radius:999px}
    .badge.good{background:var(--good-bg);color:var(--good-fg);border:1px solid #bbf7d0}
    .badge.warn{background:var(--warn-bg);color:var(--warn-fg);border:1px solid #fde68a}
    /* Red badge contrast fix */
    .badge.bad{ background: var(--bad-bg); color:#fff; border:1px solid #fecaca }
    .oee-badge{font-size:var(--tile-head-fs); line-height:1; padding:8px 12px}

    .metricrow{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:10px;margin-top:8px}
    .mitem{background:#f7fafc;border:1px solid var(--border);border-radius:10px;padding:10px;min-width:0}
    .mitem .label{font-weight:900;color:var(--muted)}
    .mitem .mkv{font-size:30px;font-weight:900}
    .spark{width:100%;height:40px;margin-top:6px}

    #rankTable {font-size: var(--rank-fs);}
    #rankTable th, #rankTable td {padding:14px}
    #rankTable { table-layout: fixed; width: 100%; }
    #rankTable th { text-align: center; }
    #rankTable td.left { text-align: left; }
    #rankTable td.pct  { text-align: center; font-variant-numeric: tabular-nums; }
    #rankTable td.num  { text-align: right;  font-variant-numeric: tabular-nums; }
    #rankTable tfoot td { font-weight: 900; border-top: 2px solid var(--border); background: #fafbff; }

    /* Production Line Status table */
    #status-table { width:100%; border-collapse:collapse; font-size:var(--status-fs); font-weight:800 }
    #status-table th, #status-table td { padding:14px; border-bottom:1px dashed var(--border) }
    #status-table thead th { background:#25408F; color:#fff; text-align:left }

    footer{display:flex;justify-content:space-between;align-items:center;margin-top:12px;color:var(--muted);font-weight:900}
    .clock{font-variant-numeric:tabular-nums;font-weight:900}

    @media (min-width:2560px){
      .app{max-width:2560px}
      .kpi .value{font-size:46px}
      .kpi .label, .badge{font-size:20px}
      .lines{gap:18px}
      .line{padding:16px}
      #rankTable {font-size: 22px;}
    }

    /* --- bottom grid: two columns on wide screens --- */
    .grid.gridWide{
      grid-template-columns: minmax(700px, 1.25fr) minmax(760px, 0.75fr);
      gap: 16px;
    }
    @media (max-width: 1600px){
      .grid.gridWide{ grid-template-columns: 1fr; }  /* stack on narrower TVs */
    }
    
    /* --- donut rows: title spans both columns; donut left, legend right --- */
    .donutwrap{
      display: grid;
      grid-auto-rows: minmax(120px, auto);
      row-gap: 18px;
    }
    
    .donutrow{
      display: grid;
      grid-template-columns: 320px minmax(540px, 1fr);  /* donut | legend */
      column-gap: 20px;
      align-items: center;
    }
    
    /* title spans both columns so the next two items line up left|right */
    .donutrow .rowtitle{
      grid-column: 1 / -1;
      margin: 0 0 6px 0;
      font-weight: 800;
      text-align: left;
    }
    
    /* donut sizing/centering */
    .donutrow canvas{
      width: 200px !important;
      height: 200px !important;
      justify-self: center;   /* keeps donut centered in its narrow column */
    }
    
    /* legend layout: Name | Hours | % */
    .legend{
      display: inline-grid;                           /* don't stretch full width */
      grid-template-columns: minmax(360px,1fr) 120px 90px;
      column-gap: 12px; row-gap: 8px;
      font-weight: 900; min-width: 0;
      font-variant-numeric: tabular-nums;
      max-width: 820px;                               /* prevent over-wide lines */
    }
    .legend .row{ display: contents; }
    .legend .name{ display:flex; gap:8px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; min-width:0; }
    .legend .hrs{  justify-self:end; }
    .legend .pct{  justify-self:end; color:#64748b; }

    /* keep legends left-aligned in their column */
    .donutrow .legend { justify-self: start; }
    
    /* FINAL OVERRIDES — put these at the end of <style> */

    /* give the page a bit more room overall */
    .app { max-width: 2300px !important; }
    
    /* wider right column (Rank table), slightly narrower left */
    .grid.gridWide{
      grid-template-columns: minmax(560px, 0.85fr) minmax(1000px, 1.15fr) !important;
      gap: 16px;
    }
    
    /* optional: on narrower screens still stack */
    @media (max-width: 1600px){
      .grid.gridWide{ grid-template-columns: 1fr !important; }
    }

  </style>
</head>

<body class="page-production">
  <div id="loading"><div class="spinner" aria-label="Loading…"></div></div>

  <div class="top-border">
    <img src="img/pri-logo.png" alt="PRI Logo" class="logo" />
    <div class="top-title">PRI Pulse <span id="periodLabel" style="font-size:18px;font-weight:900;margin-left:8px;color:#0A2A12"></span></div>
    <div class="tabs">
      <a class="tab" href="index.html">Work Orders</a>
      <a class="tab" href="pm.html">PM</a>
      <a class="tab" href="prodstatus.html">Prod Status</a>
      <a class="tab" href="kpi-by-asset.html">KPIs by Asset</a>
      <a class="tab" href="production.html">PACE</a>
      <a class="tab active" href="pulse.html">Pulse</a>
      <a class="tab" href="meeting.html">Meeting</a>
      <a class="tab" href="admin">Admin</a>
      <img src="img/innovation-logo.png" alt="Innovation" style="height:72px;margin-left:8px;object-fit:contain"/>
    </div>
  </div>

  <div class="wrap">
    <div class="app" id="app">

      <div class="toolbar">
        <div class="left">
          <div class="segBig" role="tablist" aria-label="Timeframe" id="tfButtons">
            <button data-period="today" role="tab">Today</button>
            <button data-period="yesterday" role="tab">Yesterday</button>
            <button data-period="thisweek" role="tab">This Week</button>
            <button data-period="lastweek" class="active" role="tab">Last Week</button>
            <button data-period="thismonth" role="tab">This Month</button>
            <button data-period="lastmonth" role="tab">Last Month</button>
            <button data-period="last7" role="tab">Rolling 7d</button>
            <button data-period="last30" role="tab">Rolling 30d</button>
          </div>
          <span class="pill" id="sitePill">All Sites</span>
          <span class="pill">Pick date:</span>
            <input id="dayPick" type="date" class="pill" style="padding:6px 10px" />
        </div>
        <div class="right">
          <span class="pill">Auto-refresh: <strong id="refreshSec">600s</strong></span>
          <span class="pill">Press <strong>F</strong> for Fullscreen</span>
        </div>
      </div>

      <!-- KPI STRIP -->
      <section class="kpis" id="kpiStrip"></section>

      <!-- TOP GRID: Left = Production Line Status, Right = Line Health -->
      <section class="grid">
        <article class="card">
          <h3>LIVE Line Status</h3>
          <div class="content">
            <table id="status-table" class="status-table">
              <thead>
                <tr><th>Asset Name</th><th>Current Status</th></tr>
              </thead>
              <tbody id="status-data"></tbody>
            </table>
          </div>
        </article>

        <article class="card">
          <h3>Line Health (OEE / Avail / Perf / Quality)</h3>
          <div class="content">
            <div class="lines" id="linesGrid"></div>
          </div>
        </article>
      </section>

      <!-- BOTTOM GRID: Left = Donuts, Right = Rank -->
      <section class="grid gridWide" style="margin-top:16px">
        <article class="card">
          <h3>Downtime Overview — Production & Maintenance</h3>
          <div class="donutrow">
              <div class="rowtitle">Production — Reasons</div>
              <canvas id="donutProd" width="160" height="160"></canvas>
              <div><div class="legend" id="legendProd"></div></div>
            </div>
          
          <div class="content donutwrap">
            <div class="donutrow">
              <div class="rowtitle">Maintenance — Category</div>
              <canvas id="donutMaintCat" width="160" height="160"></canvas>
              <div><div class="legend" id="legendMaintCat"></div></div>
            </div>
            
            <div class="donutrow">
              <div class="rowtitle">Maintenance — Failure Mode</div>
              <canvas id="donutMaintFm" width="160" height="160"></canvas>
              <div><div class="legend" id="legendMaintFm"></div></div>
            </div>
          
          </div>
        </article>

        <article class="card">
          <h3>Lines Ranked by OEE & Missed Opportunity</h3>
          <div class="content">
            <table id="rankTable">
              <thead>
                <tr>
                  <th style="width:28%">Line</th>
                  <th style="width:14%">OEE %</th>
                  <th style="width:22%">Pounds Produced</th>
                  <th>Missed Opp (lb)</th>
                </tr>
              </thead>
              <tbody></tbody>
              <tfoot>
                <tr id="rankTotals"></tr>
              </tfoot>
            </table>
          </div>
        </article>
      </section>

      <footer>
        <div>Last updated <span id="updated"></span></div>
        <div class="clock" id="clock"></div>
      </footer>

    </div>
  </div>

<script>
  // ====== CONFIG / CONSTANTS ======
  const REFRESH_MS = 10 * 60 * 1000; // 10 minutes
  const QUALITY_DEFAULT = 0.70;
  const PERF_CAP = 1.00;
  const MIN_RUN_H_FOR_ADJ = 0.75;
  const HOURS_PER_WEEKDAY = 24;
  const THRESH = {
    capacityAdj: { good: 0.80, warn: 0.60 },
    oee:         { good: 0.50, warn: 0.25 },
    availability:{ good: 0.80, warn: 0.60 },
    quality:     { good: 0.98, warn: 0.85 }
  };
  const grade  = (v, {good, warn}) => (v >= good ? 'good' : v >= warn ? 'warn' : 'bad');
  const MISSING = '---';
  const fmtPct = (v, valid=true) => (valid && Number.isFinite(v)) ? (Math.round(v*100) + '%') : MISSING;
  const fmtFixed = (v, digits=1, valid=true) => (valid && Number.isFinite(v)) ? v.toFixed(digits) : MISSING;
  const fmtInt = (v, valid=true) => (valid && Number.isFinite(v)) ? Number(Math.round(v)).toLocaleString() : MISSING;

  let refreshTimer = null;
  let lastRenderAt = 0;

  function setLoading(v){
    try{ const el = document.getElementById('loading'); if (el) el.style.display = v ? 'flex' : 'none'; }catch{}
  }

  // ====== TIMEFRAME ======
  function startOfWeek(d){ const x=new Date(d); const day=(x.getDay()+6)%7; x.setDate(x.getDate()-day); x.setHours(0,0,0,0); return x;}
  function endOfWeek(d){ const x=startOfWeek(d); x.setDate(x.getDate()+6); return x;}
  function startOfMonth(d){ return new Date(d.getFullYear(), d.getMonth(), 1); }
  function endOfMonth(d){ return new Date(d.getFullYear(), d.getMonth()+1, 0); }

  function computeRange(sel){
    const now = new Date(); now.setHours(0,0,0,0);
    const y = new Date(now); y.setDate(y.getDate()-1);
    const fmt = d => new Date(d.getTime()-d.getTimezoneOffset()*60000).toISOString().slice(0,10);
    const thisW = {from:startOfWeek(now), to:endOfWeek(now)};
    const lastW = {from:new Date(startOfWeek(now)), to:new Date(endOfWeek(now))}; lastW.from.setDate(lastW.from.getDate()-7); lastW.to.setDate(lastW.to.getDate()-7);
    const thisM = {from:startOfMonth(now), to:endOfMonth(now)};
    const lastM = {from:startOfMonth(new Date(now.getFullYear(), now.getMonth()-1, 1)), to:endOfMonth(new Date(now.getFullYear(), now.getMonth()-1, 1))};

    switch(sel){
      case 'today':     return {from:fmt(now), to:fmt(now), label:'Today'};
      case 'yesterday': return {from:fmt(y),   to:fmt(y),   label:'Yesterday'};
      case 'thisweek':  return {from:fmt(thisW.from), to:fmt(thisW.to), label:'This week (Mon–Sun)'};
      case 'lastweek':  return {from:fmt(lastW.from), to:fmt(lastW.to), label:'Last week (Mon–Sun)'};
      case 'thismonth': return {from:fmt(thisM.from), to:fmt(thisM.to), label:'This month'};
      case 'lastmonth': return {from:fmt(lastM.from), to:fmt(lastM.to), label:'Last month'};
      case 'last7':     { const s=new Date(now); s.setDate(s.getDate()-6); return {from:fmt(s), to:fmt(now), label:'Trailing 7 days'}; }
      case 'last30':
      default:          { const s=new Date(now); s.setDate(s.getDate()-29); return {from:fmt(s), to:fmt(now), label:'Trailing 30 days'}; }
      case 'customday': {
        const dStr = window.__pickedDay;
        if (!dStr) return { from: fmt(now), to: fmt(now), label: 'Today' };
        const d = new Date(dStr);
        d.setHours(0,0,0,0);
        return { from: fmt(d), to: fmt(d), label: d.toISOString().slice(0,10) };
      }
    }
  }

  // ====== MAPPINGS / THEME ======
  let MAPPINGS;
  async function loadMappings(){
    try {
      MAPPINGS = await (await fetch(`mappings.json?ts=${Date.now()}`, {cache:'no-store'})).json();
    } catch {
      console.warn('mappings.json not found; using empty defaults');
      MAPPINGS = { capacities_lbs_hr:{}, capacity_by_material_lbs_hr:{}, capacity_aliases:{}, material_aliases:{} };
    }
  }
  function capacityFor(lineName, material){
    const { capacities_lbs_hr: caps = {}, capacity_by_material_lbs_hr: byMat = {}, capacity_aliases: alias = {}, material_aliases: malias = {} } = MAPPINGS || {};
    const canon = (caps[lineName] !== undefined || byMat[lineName]) ? lineName : (alias[lineName] || lineName);
    const k = String(material ?? '').trim().toUpperCase();
    const m = malias[k] || (k === '' ? 'DEFAULT' : k);
    return byMat[canon]?.[m] ?? byMat[canon]?.DEFAULT ?? caps[canon] ?? 0;
  }
  async function loadThemeAndApply() {
    try {
      const t = await fetch('/api/settings/kpi-theme').then(r=>r.json());
      const c = t?.colors || {};
      if (c.good?.bg)  document.documentElement.style.setProperty('--good-bg', c.good.bg);
      if (c.good?.fg)  document.documentElement.style.setProperty('--good-fg', c.good.fg);
      if (c.warn?.bg)  document.documentElement.style.setProperty('--warn-bg', c.warn.bg);
      if (c.warn?.fg)  document.documentElement.style.setProperty('--warn-fg', c.warn.fg);
      if (c.bad?.bg)   document.documentElement.style.setProperty('--bad-bg',  c.bad.bg);
      if (c.bad?.fg)   document.documentElement.style.setProperty('--bad-fg',  c.bad.fg);
    } catch {}
  }

  // ====== SMALL HELPERS ======
  function lowClassFromPct(p){
    if (!Number.isFinite(p)) return '';
    return (p <= 0.10) ? 'good' : (p <= 0.20) ? 'warn' : 'bad';
  }
  function cssVar(name) {
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || name;
  }
  async function runFor(sel){
    const r = computeRange(sel);
    await renderForRange(r.from, r.to, r.label);
  }

  // simple palette (pulls good/warn/bad if present, then a few accents)
  function pickColor(i){
    const root = getComputedStyle(document.documentElement);
    const c1 = root.getPropertyValue('--good-fg').trim() || '#10B981';
    const c2 = root.getPropertyValue('--warn-fg').trim() || '#f59e0b';
    const c3 = root.getPropertyValue('--bad-fg').trim()  || '#ef4444';
    const pool = [c1, '#2563eb', c2, '#9333ea', c3];
    return pool[i % pool.length];
  }
    
  // Stable brand colors by reason (fallback to palette if missing)
  const REASON_COLORS = {
    MATERIAL:   '#065f46',  // deep green
    STAFFING:   '#2563eb',  // blue
    UNSTATED:   '#6b7280',  // slate gray
    ETTLINGER:  '#a855f7',  // purple
    'DIE FACE': '#7c3aed',  // indigo
    'CUTTER HEAD':'#7f5539',// brown
    CHANGEOVER: '#f59e0b',  // amber
    QUALITY:    '#ec4899',  // pink
    UTILITY:    '#06b6d4',  // cyan
    MAINTENANCE:'#ef4444',  // red (not used for prod reasons yet)
    OTHER:      '#d1d5db'   // light gray
  };
  function colorForReason(name, i){
    const key = String(name||'').toUpperCase();
    return REASON_COLORS[key] || pickColor(i);
  }

  function polarToCartesian(cx, cy, r, angDeg) {
    const a = angDeg * Math.PI / 180;
    return { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
  }
  function arcPath(cx, cy, r, startDeg, endDeg, sweepFlag) {
    const s = polarToCartesian(cx, cy, r, startDeg);
    const e = polarToCartesian(cx, cy, r, endDeg);
    const largeArc = Math.abs(endDeg - startDeg) > 180 ? 1 : 0;
    return `M ${s.x} ${s.y} A ${r} ${r} 0 ${largeArc} ${sweepFlag} ${e.x} ${e.y}`;
  }

  // ====== DONUT (no library) ======
  function drawDonut(canvas, parts){
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 6;
    ctx.clearRect(0,0,w,h);
    let total = parts.reduce((s,p)=>s+p.value,0) || 1;
    let start = -Math.PI/2;
    for (const p of parts){
      const ang = (p.value/total) * Math.PI*2;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.fillStyle = p.color;
      ctx.arc(cx,cy,r,start,start+ang,false);
      ctx.closePath();
      ctx.fill();
      start += ang;
    }
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.arc(cx,cy,r*0.62,0,Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
  }
  
  async function renderProdReasonsDonut(fromISO, toISO){
    const canvas = document.getElementById('donutProd');
    const legend = document.getElementById('legendProd');
    if (!canvas || !legend) return;
  
    // Pull production reasons for weekdays only (to match the rest of Pulse math)
    const url = `/api/production/dt-reasons?kind=prod&from=${fromISO}&to=${toISO}&weekdaysOnly=1`;
    let data = null;
    try { data = await fetch(url, {cache:'no-store'}).then(r=>r.json()); } catch {}
    const rows = Array.isArray(data?.reasons) ? data.reasons.filter(r => (r?.hours||0) > 0) : [];
    const total = rows.reduce((s, r) => s + (r.hours || 0), 0);
  
    // If nothing, show a neutral donut
    if (total <= 0 || rows.length === 0) {
      drawDonut(canvas, [{name:'No data', value:1, color:'#d1d5db'}]);
      legend.innerHTML = `<div class="row"><span class="dot" style="background:#d1d5db"></span><div class="name">No production reasons</div><div class="val">—</div></div>`;
      return;
    }
  
    // Top 5 + Other
    const top = rows.slice().sort((a,b)=>b.hours-a.hours).slice(0,5);
    const topSum = top.reduce((s,r)=>s+(r.hours||0),0);
    const other  = Math.max(0, total - topSum);
  
    const parts = top.map((r, i) => ({
       name: r.reason,
       value: r.hours,
       color: colorForReason(r.reason, i)
     }));
    if (other > 0) parts.push({ name:'Other', value: other, color:'#d1d5db' });
  
    // Draw donut
    drawDonut(canvas, parts);
  
    // Legend (name • hours • %)
    legend.innerHTML = parts.map(p => {
      const pct = total > 0 ? (p.value/total*100).toFixed(0)+'%' : '—';
      const hrs = (p.value||0).toFixed(1)+'h';
      return `
        <div class="row">
          <div class="name" title="${p.name}">
            <span class="dot" style="background:${p.color}"></span>${p.name}
          </div>
          <div class="hrs">${hrs}</div>
          <div class="pct">${pct}</div>
        </div>`;
    }).join('');
  }

  // Failure Mode palette (distinct, high-contrast)
const FM_COLORS = {
  'WATER LEAK':'#0ea5e9','FEEDER BLOCKAGE':'#2563eb','MACHINE DAMAGED':'#111827',
  'SCREEN CLOG':'#7c3aed','BELT WORN':'#6b7280','CONTACTOR RELAY':'#ef4444',
  'POWER TRIP':'#f59e0b','DIE BUILDUP':'#22c55e','CYLINDER STUCK':'#a855f7'
};

function hashColor(name, i=0){
  const s = String(name||'').toUpperCase();
  let h = 2166136261>>>0;
  for (let c of s){ h ^= c.charCodeAt(0); h = Math.imul(h,16777619); }
  const hue = h % 360; return `hsl(${hue} 68% 48%)`;
}

function colorForFM(name,i){
  const key = String(name||'').toUpperCase();
  return FM_COLORS[key] || hashColor(key, i);
}

  async function renderDowntimeDonutsPulse(fromISO, toISO){
  const wq = '1'; // keep weekday-only on Pulse; or wire to your toggle if you have one

  const [prod, cat, fm] = await Promise.all([
    fetch(`/api/production/dt-reasons?kind=prod&from=${fromISO}&to=${toISO}&weekdaysOnly=${wq}`).then(r=>r.json()),
    fetch(`/api/production/dt-reasons?kind=maint&dim=cat&from=${fromISO}&to=${toISO}&weekdaysOnly=${wq}`).then(r=>r.json()),
    fetch(`/api/production/dt-reasons?kind=maint&dim=fm&from=${fromISO}&to=${toISO}&weekdaysOnly=${wq}`).then(r=>r.json())
  ]);

  const make = (payload, canvasId, legendId, colorChooser) => {
  const TOP_N = 6;
  const rowsAll = (payload?.reasons || []).filter(r => (r.hours||0) > 0);
  if (!rowsAll.length) {
    // draw a neutral donut, same as your existing branch if you want
    const ctx = document.getElementById(canvasId).getContext('2d');
    if (ctx.__chart) ctx.__chart.destroy();
    const legend = document.getElementById(legendId);
    legend.innerHTML = '<div class="row"><div class="name">No data</div><div class="hrs">—</div><div class="pct">—</div></div>';
    return;
  }

  const total = rowsAll.reduce((a,b)=>a + (b.hours||0), 0);
  const sorted = rowsAll.slice().sort((a,b)=> (b.hours||0) - (a.hours||0));
  const top = sorted.slice(0, TOP_N);
  const topSum = top.reduce((a,b)=>a + (b.hours||0), 0);
  const other = Math.max(0, total - topSum);
  const items = other > 0 ? [...top, { reason: 'Other', hours: other }] : top;

  const labels = items.map(r => r.reason);
  const data   = items.map(r => +((r.hours||0).toFixed(1)));
  const colors = items.map((r,i) => colorChooser(r.reason, i));

  const ctx = document.getElementById(canvasId).getContext('2d');
  if (ctx.__chart) ctx.__chart.destroy();

  ctx.__chart = new Chart(ctx, {
    type: 'doughnut',
    data: { labels, datasets: [{ data, backgroundColor: colors }] },
    options: { responsive: false, cutout: '60%', plugins: { legend: { display: false }, tooltip: { enabled: true } } }
  });

  // legend
  const legend = document.getElementById(legendId);
  legend.innerHTML = '';
  items.forEach((r,i) => {
    const pct = total ? (r.hours/total) : 0;
    const color = colors[i];
    const row = document.createElement('div');
    row.className = 'row';
    row.innerHTML = `
      <div class="name"><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${color};margin-right:8px"></span>${r.reason}</div>
      <div class="hrs">${r.hours.toFixed(1)} h</div>
      <div class="pct">${Math.round(pct*100)}%</div>`;
    legend.appendChild(row);
  });
};


  // color pickers
  const colorForProd = (name, i) => colorForReason(name, i);
  const MAINT_CAT_COLORS = {
      'Mechanical':'#4b5563','Electrical':'#2563eb','Thermal':'#f97316','Hydraulic':'#0ea5e9',
      'Process':'#16a34a','Utilities':'#0891b2','Consumables':'#a855f7','Human Factors':'#ef4444','Other':'#9ca3af'
    };
    const colorForCat = (name, i) => MAINT_CAT_COLORS[name] || pickColor(i);
    const colorForFm   = (name, i) => colorForFM(name, i);


  make(cat, 'donutMaintCat', 'legendMaintCat', colorForCat);
  make(fm,  'donutMaintFm',  'legendMaintFm',  colorForFm); 
  make(prod,'donutProd',     'legendProd',     colorForProd);
}


  // ====== PROD STATUS (same data as prodstatus.html) ======
  async function getProdStatusRows(){
    try{
      const res = await fetch('/api/workorders/prodstatus?t=' + Date.now(), { cache:'no-store' });
      if (!res.ok) return [];
      let data = await res.json();
      let rows = Array.isArray(data?.rows) ? data.rows
              : (Array.isArray(data?.tiles) ? data.tiles : []);
      // SQL wrapper normalizer
      if (Array.isArray(rows) && rows.length === 1 && rows[0] && typeof rows[0] === 'object'){
        const k = Object.keys(rows[0])[0];
        const v = k && rows[0][k];
        if (typeof v === 'string' && v.trim().startsWith('[')) {
          try { rows = JSON.parse(v); } catch {}
        }
      }
      return rows || [];
    }catch{
      return [];
    }
  }

  function renderStatusTable(rows){
    const tbody = document.getElementById('status-data');
    if (!tbody) return;
    tbody.innerHTML = '';

    const colorMap = MAPPINGS?.statusColorMapping || {};
    const textMap  = MAPPINGS?.statusTextMapping  || {};
    const assets   = Array.isArray(MAPPINGS?.productionAssets) ? MAPPINGS.productionAssets : [];

    const toText = (raw) => {
      const v = (raw ?? 'N/A');
      if (typeof v === 'number' || (/^\d+$/).test(String(v).trim())) {
        return (textMap[String(v)] || String(v)).replace(/\u00A0/g, ' ').trim();
      }
      return String(v).replace(/\u00A0/g, ' ').trim();
    };
    const colorFor = (txt) => {
      const idFromText = Object.keys(textMap).find(k => (textMap[k]||'').toString().toLowerCase() === txt.toLowerCase());
      const keyForColor = idFromText || txt;
      return colorMap[keyForColor] || '#fff';
    };

    if (assets.length > 0) {
      const byId = (id) => rows.find(r => String(r.assetID) === String(id)) || {};
      assets.slice().sort((a,b)=> String(a.name).localeCompare(String(b.name))).forEach(item=>{
        const entry = byId(item.id);
        const raw =
          entry.assetStatus ?? entry.value ?? entry.valueText ??
          entry.statusText  ?? entry.status ?? entry.statusID ?? 'N/A';
        const text = toText(raw);
        const bg   = colorFor(text);

        const tr = document.createElement('tr');
        tr.style.backgroundColor = bg;
        tr.style.color = (/^(#d64550|red|#118dff|blue)$/i.test(String(bg))) ? '#fff' : '#000';
        tr.innerHTML = `<td>${item.name}</td><td>${text}</td>`;
        tbody.appendChild(tr);
      });
      return;
    }

    // Fallback: no productionAssets in mappings → render everything we can find
    const guessName = (r) => r.assetName || r.name || r.machine || r.line || r.asset || '';
    const guessRaw  = (r) => r.assetStatus ?? r.value ?? r.valueText ?? r.statusText ?? r.status ?? r.statusID ?? 'N/A';
    const list = rows.map(r => ({ name: guessName(r), text: toText(guessRaw(r)) })).filter(r => r.name);

    if (list.length === 0) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td colspan="2" style="color:#7f1d1d;font-weight:800">No status rows found. Check /api/workorders/prodstatus and mappings.productionAssets.</td>`;
      tbody.appendChild(tr);
      return;
    }

    list.sort((a,b)=> a.name.localeCompare(b.name)).forEach(({name, text})=>{
      const bg = colorFor(text);
      const tr = document.createElement('tr');
      tr.style.backgroundColor = bg;
      tr.style.color = (/^(#d64550|red|#118dff|blue)$/i.test(String(bg))) ? '#fff' : '#000';
      tr.innerHTML = `<td>${name}</td><td>${text}</td>`;
      tbody.appendChild(tr);
    });
  }

  async function loadAndRenderStatusTable(){
    if (!MAPPINGS) { try { await loadMappings(); } catch {} }
    const rows = await getProdStatusRows();
    renderStatusTable(rows);
  }

  // ====== CORE RENDERER (range) ======
  async function renderForRange(fromISO, toISO, label){
    setLoading(true);
    try{
      await loadThemeAndApply();
      document.getElementById('periodLabel').textContent = `(${label})`;

      const [summaryRaw, bylineRaw] = await Promise.all([
        fetch(`/api/production/summary?from=${fromISO}&to=${toISO}`).then(r=>r.json()).catch(()=>null),
        fetch(`/api/production/by-line?from=${fromISO}&to=${toISO}`).then(r=>r.json()).catch(()=>[])
      ]);

      const byline = (bylineRaw || []).filter(r => r.machine && r.machine.startsWith('Extruder'));

      // build calendar (weekdays only)
      const planDays = [];
      { const from = new Date(fromISO+'T00:00:00'); const to=new Date(toISO+'T00:00:00');
        for (let d=new Date(from); d<=to; d.setDate(d.getDate()+1)) {
          const wd = d.getDay();
          const iso = new Date(d.getTime()-d.getTimezoneOffset()*60000).toISOString().slice(0,10);
          if (wd !== 0 && wd !== 6) planDays.push(iso);
        }
      }
      const planDaysCount = planDays.length;

      // consolidate to machine-days
      const dayMap = new Map();
      for (const row of byline){
        const machine = row.machine;
        const day = (row.src_date||'').slice(0,10);
        if (!machine || !day || !planDays.includes(day)) continue;

        const capRow = capacityFor(row.machine, row.material);
        const lbs  = row.pounds || 0;
        const md   = Math.max(0, row.maint_dt_h    || 0);
        const mhR  = Math.max(0, row.machine_hours || 0);
        const runH = mhR;

        const key = `${machine}__${day}`;
        if (!dayMap.has(key)) dayMap.set(key, {machine, day, lbs:0, maint_h:0, run_h:0, sumCapRun:0, sumRunH:0, cap_candidates:[], mats:{}});
        const d = dayMap.get(key);
        d.lbs += lbs;
        d.maint_h = Math.max(d.maint_h, md);
        d.run_h   = Math.max(d.run_h,   runH);
        if (capRow > 0) { d.sumCapRun += capRow * runH; d.sumRunH += runH; d.cap_candidates.push(capRow); }
        const matKey = String(row.material || '').trim().toUpperCase() || 'DEFAULT';
        d.mats[matKey] = (d.mats[matKey] || 0) + lbs;
      }

      for (const d of dayMap.values()) {
        let capDay = 0;
        if (d.sumRunH > 0) capDay = d.sumCapRun / d.sumRunH;
        else if (d.cap_candidates.length) { const arr = d.cap_candidates.slice().sort((a,b)=>a-b); capDay = arr[Math.floor(arr.length/2)]; }
        d.cap = capDay;
        const run = d.run_h, maint = d.maint_h;
        let prod = Math.max(0, HOURS_PER_WEEKDAY - maint - run);
        const over = Math.max(0, (maint + run + prod) - HOURS_PER_WEEKDAY);
        d.prod_h = Math.max(0, prod - over);
        d.avail    = HOURS_PER_WEEKDAY ? (run / HOURS_PER_WEEKDAY) : 0;
        const rawDen = capDay * HOURS_PER_WEEKDAY;
        const runDen = capDay * run;
        d.perfRaw  = rawDen > 0 ? Math.min(d.lbs / rawDen, PERF_CAP) : NaN;
        d.perfRun  = (run >= MIN_RUN_H_FOR_ADJ && runDen > 0) ? Math.min(d.lbs / runDen, PERF_CAP) : NaN;
        d.underLb  = Math.max(0, capDay * run - d.lbs);
      }

      // aggregate per line
      const agg = {};
      for (const d of dayMap.values()){
        const m = d.machine;
        if (!agg[m]) agg[m] = { lbs:0, maint:0, prod:0, mach:0, rawDen24:0, runCapDen:0, moM:0, moP:0, under:0, sumAvail:0,nAvail:0,sumPR:0,nPR:0,sumPRun:0,nPRun:0, mats:{}, daysSet:new Set() };
        const A = agg[m];
        A.lbs += d.lbs; A.maint += d.maint_h; A.prod += d.prod_h; A.mach += d.run_h;
        A.rawDen24 += d.cap * HOURS_PER_WEEKDAY;
        A.runCapDen+= d.cap * d.run_h;
        A.moM      += d.cap * d.maint_h;
        A.moP      += d.cap * d.prod_h;
        A.under    += d.underLb;
        A.sumAvail += (Number.isFinite(d.avail)?d.avail:0); A.nAvail+=1;
        if (Number.isFinite(d.perfRaw)) { A.sumPR   += d.perfRaw; A.nPR   += 1; }
        if (Number.isFinite(d.perfRun)) { A.sumPRun += d.perfRun; A.nPRun += 1; }
        A.daysSet.add(d.day);
        let dom='', best=-1; for (const [k,v] of Object.entries(d.mats)) if (v>best){ best=v; dom=k; }
        if (dom) A.mats[dom] = (A.mats[dom] || 0) + d.lbs;
      }

      const perLine = Object.keys(agg).sort().map(machine => {
        const A = agg[machine];
        const days = A.daysSet.size || 0;
        let domMat = ''; if (A.mats && Object.keys(A.mats).length) { let best=-1; for (const [k,v] of Object.entries(A.mats)) if (v>best){ best=v; domMat=k; } }
        const availability = A.nAvail>0 ? (A.sumAvail / A.nAvail) : NaN;
        const perfRaw      = A.nPR>0    ? (A.sumPR   / A.nPR)    : NaN;
        const perfRun      = A.nPRun>0  ? (A.sumPRun / A.nPRun)  : NaN;
        const qual         = QUALITY_DEFAULT;
        const oee          = (Number.isFinite(availability) && Number.isFinite(perfRun)) ? (availability * perfRun * qual) : NaN;
        const capAvg   = (A.rawDen24 > 0 && days>0) ? (A.rawDen24 / (HOURS_PER_WEEKDAY * days)) : NaN;
        const plannedH = HOURS_PER_WEEKDAY * planDaysCount;
        const idleDays = Math.max(0, planDaysCount - days);
        const prodH    = A.prod + HOURS_PER_WEEKDAY * idleDays;
        const moP_idle = (Number.isFinite(capAvg) ? capAvg : 0) * HOURS_PER_WEEKDAY * idleDays;
        const moP      = (A.moP || 0) + moP_idle;
        const underLb  = Math.max(0, A.runCapDen - A.lbs);
        const capPot   = (Number.isFinite(capAvg) ? capAvg : 0) * HOURS_PER_WEEKDAY * planDaysCount;
        const mPct = plannedH > 0 ? (A.maint / plannedH) : NaN;
        const pPct = plannedH > 0 ? (prodH  / plannedH) : NaN;
        
        return {
          machine, domMat,
          lbs: A.lbs, maint: A.maint, prod: prodH, mach: A.mach,
          rawDen24: A.rawDen24, capPot, runCapDen: A.runCapDen, underLb,
          moM: A.moM, moP, days, plannedH, capAvg,
          avail: availability, perfRaw, perfRun, qual, oee,
          availV: A.nAvail>0, prV: A.nPR>0, prunV: A.nPRun>0, oeeV: A.nAvail>0 && A.nPRun>0,
          mPct, pPct
        };
      });

      // totals
      const totals = Object.values(agg).reduce((s, A) => {
        s.lbs += A.lbs; s.maint += A.maint; s.prod += A.prod; s.mach += A.mach;
        s.rawDen24 += A.rawDen24; s.runCapDen += A.runCapDen;
        s.moM += A.moM; s.moP += A.moP; s.under += Math.max(0, A.runCapDen - A.lbs);
        s.sumAvail += A.sumAvail; s.nAvail += A.nAvail;
        s.sumPR += A.sumPR; s.nPR += A.nPR;
        s.sumPRun += A.sumPRun; s.nPRun += A.nPRun;
        s.plannedH += HOURS_PER_WEEKDAY * planDaysCount;
        return s;
      }, {lbs:0,maint:0,prod:0,mach:0,rawDen24:0,runCapDen:0,moM:0,moP:0,under:0,sumAvail:0,nAvail:0,sumPR:0,nPR:0,sumPRun:0,nPRun:0,plannedH:0});

      const totalCapPot   = perLine.reduce((s, r) => s + (r.capPot || 0), 0);
      const ovAvail   = totals.nAvail>0 ? (totals.sumAvail / totals.nAvail) : 0;
      const ovPerfRaw = totals.nPR>0    ? (totals.sumPR    / totals.nPR)    : 0;
      const ovPerfRun = totals.nPRun>0  ? (totals.sumPRun  / totals.nPRun)  : 0;
      const ovOEE     = ovAvail * ovPerfRun * QUALITY_DEFAULT;
      const ovMdtPct  = totals.plannedH > 0 ? (totals.maint / totals.plannedH) : 0;
      const ovPdtPct  = totals.plannedH > 0 ? (totals.prod  / totals.plannedH) : 0;

      const kpis = [
        {id:'oee',   label:'OEE',            val:fmtPct(ovOEE, totals.nAvail>0 && totals.nPRun>0), cls:grade(ovOEE, THRESH.oee),                  show:true},
        {id:'avail', label:'Availability',   val:fmtPct(ovAvail, totals.nAvail>0),                cls:grade(ovAvail, THRESH.availability), show:true},
        {id:'prun',  label:'Performance Adj',     val:fmtPct(ovPerfRun, totals.nPRun>0),               cls:grade(ovPerfRun, THRESH.capacityAdj), show:true},
        {id:'qual',  label:'Quality*',       val:Math.round(QUALITY_DEFAULT*100)+'%',             cls:grade(QUALITY_DEFAULT, THRESH.quality), show:true},
        {id:'cap',   label:'Capacity Potential (lb)', val:fmtInt(totalCapPot,true),                cls:'', show:true},
        {id:'lbs',   label:'Pounds Produced',         val:fmtInt(totals.lbs,true),                         cls:'', show:true},
      ];
      document.getElementById('kpiStrip').innerHTML = kpis.filter(k=>k.show).map(k=>`
        <div class="kpi ${k.cls}">
          <div class="label">${k.label}</div>
          <div class="value">${k.val}</div>
        </div>`).join('');

      await renderDowntimeDonutsPulse(fromISO, toISO);
      
      // Line tiles
      const linesGrid = document.getElementById('linesGrid');
      linesGrid.innerHTML = '';
      perLine.forEach(r=>{
        const oeeCls  = (r.oeeV && Number.isFinite(r.oee)) ? grade(r.oee, THRESH.oee) : '';
        const mCls = lowClassFromPct(r.mPct);
        const pCls = lowClassFromPct(r.pPct);
        const html = `
          <div class="line">
            <div class="lineheader">
              <div class="linename">${r.machine}</div>
              <div class="badge ${oeeCls} oee-badge">OEE ${fmtPct(r.oee, r.oeeV)}</div>
            </div>
            <div style="margin-top:6px;color:#64748b;font-weight:800">
              Nameplate ${Number.isFinite(r.capAvg)?Math.round(r.capAvg).toLocaleString():'--'} lb/hr${r.domMat?` (${r.domMat})`:''}
            </div>
            <div class="metricrow">
              <div class="mitem"><div class="label">Avail</div><div class="mkv">${fmtPct(r.avail, r.availV)}</div></div>
              <div class="mitem"><div class="label">Perf-Run</div><div class="mkv">${fmtPct(r.perfRun, r.prunV)}</div></div>
              <div class="mitem"><div class="label">Quality*</div><div class="mkv">${Math.round(r.qual*100)}%</div></div>
              <div class="mitem"><div class="label">Pounds</div><div class="mkv">${fmtInt(r.lbs,true)}</div></div>
            </div>
            <div style="display:flex;gap:16px;margin-top:8px">
              <span class="badge ${mCls}">
                Maint DT ${fmtFixed(r.maint,1,true)}h (${fmtPct(r.mPct, Number.isFinite(r.mPct))})
              </span>
              <span class="badge ${pCls}">
                Prod DT ${fmtFixed(r.prod,1,true)}h (${fmtPct(r.pPct, Number.isFinite(r.pPct))})
              </span>
            </div>
          </div>`;
        const el = document.createElement('div'); el.innerHTML = html; linesGrid.appendChild(el.firstElementChild);
      });

      // ====== Rank table ======
      {
        const tbody = document.querySelector('#rankTable tbody');
        const tfootRow = document.getElementById('rankTotals');
      
        const ranked = perLine.slice().sort((a, b) => {
        const aHas = Number.isFinite(a.oee);
        const bHas = Number.isFinite(b.oee);
        const moA = (a.moM || 0) + (a.moP || 0);
        const moB = (b.moM || 0) + (b.moP || 0);
      
        // 1) rows with OEE come first
        if (aHas && !bHas) return -1;
        if (!aHas && bHas) return 1;
      
        // 2) both have OEE -> sort by OEE desc, then Missed Opp asc as tie-breaker
        if (aHas && bHas) {
          if (b.oee !== a.oee) return b.oee - a.oee;
          return moA - moB;
        }
      
        // 3) neither has OEE -> keep them at the bottom; sort by Missed Opp desc
        //    (or asc if you want the “least bad” first)
        return moB - moA;
      });
      
        let sumPounds = 0;
        let sumMissed = 0;
      
        const rowsHtml = ranked.map(r=>{
          const totMiss = (r.moM||0) + (r.moP||0);
          sumPounds += (r.lbs||0);
          sumMissed += totMiss;
          return `<tr>
            <td class="left">${r.machine}</td>
            <td class="pct">${fmtPct(r.oee, r.oeeV)}</td>
            <td class="num">${fmtInt(r.lbs,true)}</td>
            <td class="num">${fmtInt(totMiss,true)}</td>
          </tr>`;
        }).join('');
      
        tbody.innerHTML = rowsHtml;
      
        // totals row
        tfootRow.innerHTML = `
          <td class="left">TOTAL</td>
          <td class="pct">—</td>
          <td class="num">${fmtInt(sumPounds, true)}</td>
          <td class="num">${fmtInt(sumMissed, true)}</td>
        `;
      }

      // Also update the live prod status table now
      await loadAndRenderStatusTable();

      document.getElementById('updated').textContent = new Date().toLocaleString();

    } finally {
      setLoading(false);
      lastRenderAt = Date.now();
    }
  }

  // ====== UI wiring ======
  function scheduleAutoRefresh(run){
    if (refreshTimer) clearTimeout(refreshTimer);
    refreshTimer = setTimeout(async ()=>{ await run(); scheduleAutoRefresh(run); }, REFRESH_MS);
  }
  function currentPeriod(){
    const btn = document.querySelector('#tfButtons button.active');
    return btn?.dataset.period || 'last30';
  }
  async function runForActivePeriod(){
    const sel = currentPeriod();
    const r = computeRange(sel);
    await renderForRange(r.from, r.to, r.label);
  }

  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      const age = Date.now() - lastRenderAt;
      if (age > REFRESH_MS * 0.9) runForActivePeriod();
    }
  });

  document.addEventListener('DOMContentLoaded', async () => {
    // Fullscreen toggle
    document.addEventListener('keydown', (e)=>{
      if (e.key.toLowerCase()==='f') {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{});
        else document.exitFullscreen().catch(()=>{});
      }
    });

    // timeframe buttons
    document.querySelectorAll('#tfButtons button').forEach(b=>{
      b.addEventListener('click', async ()=>{
        document.querySelectorAll('#tfButtons button').forEach(x=>x.classList.remove('active'));
        b.classList.add('active');
        await runForActivePeriod();
      });
    });

    // Date picker wiring (add this)
    const dayPick = document.getElementById('dayPick');
    if (dayPick) {
      // optional: keep users from picking the future
      const tzToday = new Date(); tzToday.setHours(0,0,0,0);
      dayPick.max = new Date(tzToday.getTime() - tzToday.getTimezoneOffset()*60000)
                      .toISOString().slice(0,10);
  
      dayPick.addEventListener('change', async (e) => {
        if (!e.target.value) return;
        window.__pickedDay = e.target.value + 'T00:00:00';
        // clear active state from timeframe buttons
        document.querySelectorAll('#tfButtons button.active')
          ?.forEach(b => b.classList.remove('active'));
        // render for the custom day
        await runFor('customday');
        // label polish
        const lab = document.getElementById('periodLabel');
        if (lab) lab.textContent = `(${e.target.value})`;
      });
    }
    if (dayPick && !dayPick.value) {
      const y = new Date(); y.setDate(y.getDate()-1); y.setHours(0,0,0,0);
      dayPick.value = new Date(y.getTime() - y.getTimezoneOffset()*60000).toISOString().slice(0,10);
    }
    
    // Clock
    function tickClock(){
      const el = document.getElementById('clock');
      if (el) el.textContent = new Date().toLocaleString();
    }
    setInterval(tickClock, 1000); tickClock();

    // Load mappings first (needed for productionAssets + status maps)
    await loadMappings();

    // Initial status render + 60s auto-refresh (independent of the big 10m refresh)
    await loadAndRenderStatusTable();
    setInterval(loadAndRenderStatusTable, 60_000);

    // First KPI/tiles render + 10m auto-refresh
    await runForActivePeriod();
    scheduleAutoRefresh(runForActivePeriod);
  });
</script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</body>
</html>
