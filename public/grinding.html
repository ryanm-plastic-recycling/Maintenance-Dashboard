<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PRI Pulse – Grinding</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --pri-blue:#25408F; --pri-green:#92D050;
      --bg:#F1F5F9; --card:#FFFFFF; --ink:#0F172A; --muted:#475569; --border:#E2E8F0;
      --shadow:0 10px 25px rgba(0,0,0,.06)
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;font-weight:800}
    .top{position:fixed;top:0;left:0;right:0;height:88px;background:var(--pri-green);display:flex;align-items:center;padding:10px 18px;z-index:20}
    .top img{height:64px}
    .title{margin-left:12px;font-size:26px;color:#072014;font-weight:900}
    .wrap{margin:120px 20px 40px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:16px;box-shadow:var(--shadow);margin-bottom:16px}
    .seg{display:inline-flex;border-radius:12px;overflow:hidden;border:1px solid var(--border)}
    .seg button{padding:8px 12px;border:0;background:transparent;font-weight:900;cursor:pointer;color:var(--muted)}
    .seg button.active{background:var(--pri-blue);color:#fff}
    #loading{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(255,255,255,.6);z-index:999}
    #loading .spinner{width:56px;height:56px;border:8px solid #e6e6e6;border-top-color:var(--pri-blue);border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .grid{display:grid;grid-template-columns:1fr 2fr;gap:14px}
    @media(max-width:1000px){.grid{grid-template-columns:1fr}}
    .kpis{display:flex;gap:12px}
    .tile{flex:1;padding:12px;border-radius:10px;border:1px solid var(--border);background:#fbfdff;text-align:center}
    .tile .lab{font-size:12px;color:var(--muted);text-transform:uppercase;font-weight:900}
    .tile .val{font-size:22px;font-weight:900;margin-top:8px}
    .lines{display:grid;gap:12px}
    .line{padding:12px;border-radius:10px;border:1px solid var(--border);background:#fff;display:flex;justify-content:space-between;align-items:center}
    footer{margin-top:12px;color:var(--muted);font-weight:900;display:flex;justify-content:space-between}
    table{width:100%;border-collapse:collapse}
    th,td{padding:10px;border-bottom:1px dashed var(--border);text-align:center}
    th{text-align:left;color:var(--muted);font-weight:900}
  </style>
</head>
<body>
  <div id="loading"><div class="spinner" aria-hidden></div></div>

  <div class="top">
    <img src="img/pri-logo.png" alt="PRI"/>
    <div class="title">PRI Pulse – Grinding</div>
  </div>

  <div class="wrap">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="seg" role="tablist">
            <button data-period="r7" class="active">Rolling 7d</button>
            <button data-period="r30">Rolling 30d</button>
            <button data-period="week">This Week</button>
            <button data-period="lastweek">Last Week</button>
          </div>
          <div style="margin-top:8px;color:var(--muted);font-weight:900">Grinding assets only</div>
        </div>
        <div style="text-align:right">
          <div style="font-weight:900;color:var(--muted)">Auto-refresh 10m • Press F for fullscreen</div>
          <div id="rangeLabel" style="color:var(--muted);font-weight:900;margin-top:6px">—</div>
        </div>
      </div>
    </div>

    <div class="grid">
      <section class="card">
        <h3 style="margin:0 0 10px 0">Grinding Overall</h3>
        <div class="kpis">
          <div class="tile">
            <div class="lab">Availability</div>
            <div class="val" id="ov-grind-av">0%</div>
          </div>
          <div class="tile">
            <div class="lab">Maintenance Downtime</div>
            <div class="val" id="ov-grind-maint">0%</div>
          </div>
          <div class="tile">
            <div class="lab">Performance</div>
            <div class="val" id="ov-grind-pr">0%</div>
          </div>
        </div>
        <div style="margin-top:12px;color:var(--muted)">If LIMBLE endpoints are missing the page will continue to show aggregated results from other sources.</div>
      </section>

      <section class="card">
        <h3 style="margin:0 0 10px 0">Line Health — Grinding</h3>
        <div id="linesGrid" class="lines"></div>
      </section>
    </div>

    <div class="card">
      <h3 style="margin:0 0 12px 0">Ranked Lines</h3>
      <table id="rankTable">
        <thead>
          <tr><th>Line</th><th>Perf %</th><th>Avail %</th><th>Pounds</th><th>Maint h</th><th>Missed 8h</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <footer>
      <div>Last updated <span id="updated">—</span></div>
      <div id="clock" style="font-variant-numeric:tabular-nums"></div>
    </footer>
  </div>

<script>
  const ENDPOINTS = {
    BY_LINE:'/api/production/by-line',
    PRODSTATUS:'/api/workorders/prodstatus',
    LIMBLE_ASSETFIELDS:'/api/limble/assetfields',
    LIMBLE_KPIASSET:'/api/limble/kpiassetfields',
    ASSETS_FIELDS:'/api/assets/fields',
    MAP:'mappings.json'
  };

  const COLOR = { good:'#10B981', warn:'#FBBF24', bad:'#EF4444' };
  const STATE={ period:'r7' };
  const $ = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));

  function setLoading(v){ const el=$('#loading'); if(el) el.style.display = v ? 'flex' : 'none'; }
  async function fetchJSON(url, opts={}){ try{ const r = await fetch(url + (url.includes('?') ? '&' : '?') + 'ts=' + Date.now(), opts); if(!r.ok) throw new Error(r.status); return await r.json(); } catch(e){ console.warn('fetchJSON fail', url, e); return null; } }

  // Normalizers / heuristics
  function normalizeNameKey(n){ return String(n||'').replace(/[^a-z0-9\s]/gi,' ').replace(/\s+/g,' ').trim().toLowerCase(); }
  const DEFAULT_GRIND_CANON = [
    {canon:'Grinder V1', aliases:['Grinder V1','Grinder 1','V1','Grinder V 1','GrinderV1']},
    {canon:'Grinder V2', aliases:['Grinder V2','Grinder 2','V2','GrinderV2']},
    {canon:'Shredder 1', aliases:['Shredder 1','Shredder 01','Shredder1']},
    {canon:'Shredder 2', aliases:['Shredder 2','Shredder2']},
    {canon:'Weima', aliases:['Weima','Shredding Line 6- WEIMA','Weima 6']}
  ];

  const GRIND_ALIAS_REV = new Map();
  function buildDefaultAlias(){ GRIND_ALIAS_REV.clear(); for(const r of DEFAULT_GRIND_CANON){ GRIND_ALIAS_REV.set(normalizeNameKey(r.canon), r.canon); (r.aliases||[]).forEach(a => GRIND_ALIAS_REV.set(normalizeNameKey(a), r.canon)); } }
  buildDefaultAlias();

  let MAPPINGS = null;
  function updateGrindFromMappings(mapObj){
    if(!mapObj) return;
    // Use grindingAssets if present
    if(Array.isArray(mapObj.grindingAssets) && mapObj.grindingAssets.length){
      for(const it of mapObj.grindingAssets){
        const rawName = (typeof it === 'string') ? it : (it.name || it.title || '');
        if(!rawName) continue;
        const canon = String(rawName).trim();
        GRIND_ALIAS_REV.set(normalizeNameKey(canon), canon);
        // reduced forms & numeric id
        const reduced = canon.replace(/\b(grinder|grinding|shredder|line|v)\b/gi,'').replace(/\s+/g,' ').trim();
        if(reduced) GRIND_ALIAS_REV.set(normalizeNameKey(reduced), canon);
        const numeric = canon.match(/\d+/);
        if(numeric) GRIND_ALIAS_REV.set(normalizeNameKey(numeric[0]), canon);
      }
    }
    // include capacity_aliases and capacities as candidates
    const candidates = Object.assign({}, mapObj.capacity_aliases, mapObj.capacities_lbs_hr, mapObj.capacity_by_material_lbs_hr);
    for(const k of Object.keys(candidates||{})){ const canon = String(k).trim(); if(canon) GRIND_ALIAS_REV.set(normalizeNameKey(canon), canon); }
  }

  function canonGrinding(n){ if(!n) return ''; const norm = normalizeNameKey(n); return GRIND_ALIAS_REV.get(norm) || String(n||'').trim(); }
  function isGrindingMachine(n){ if(!n) return false; const c = canonGrinding(n); return Array.from(GRIND_ALIAS_REV.values()).map(x=>x.trim()).includes(String(c).trim()); }

  function fmtPct(v){ return Number.isFinite(Number(v)) ? (Math.round(Number(v)*100)+'%') : '0%'; }
  function fmtNum(n){ return Number.isFinite(Number(n)) ? Math.round(Number(n)).toLocaleString() : '0'; }
  function fmtH(v){ return Number.isFinite(Number(v)) ? Number(v).toFixed(1) : '0.0'; }

  async function loadMappings(){ if(MAPPINGS) return MAPPINGS; MAPPINGS = await fetchJSON(ENDPOINTS.MAP) || {}; updateGrindFromMappings(MAPPINGS); return MAPPINGS; }

  // color pick simple
  function pickColor(frac){
    if(frac >= 0.85) return COLOR.good;
    if(frac >= 0.7) return COLOR.warn;
    return COLOR.bad;
  }

  async function renderGrinding(){
    setLoading(true);
    try{
      await loadMappings();
      $('#rangeLabel').textContent = STATE.period;

      // calculate date range
      const now = new Date(); now.setHours(0,0,0,0);
      function iso(d){ return new Date(d.getTime()-d.getTimezoneOffset()*60000).toISOString().slice(0,10); }
      let from,to;
      if(STATE.period==='r7'){ const s=new Date(now); s.setDate(s.getDate()-6); from=iso(s); to=iso(now); }
      else if(STATE.period==='r30'){ const s=new Date(now); s.setDate(s.getDate()-29); from=iso(s); to=iso(now); }
      else if(STATE.period==='week'){ const d=new Date(now); const day=(d.getDay()+6)%7; d.setDate(d.getDate()-day); from=iso(d); const e=new Date(d); e.setDate(e.getDate()+6); to=iso(e);}
      else { const s=new Date(now); s.setDate(s.getDate()-6); from=iso(s); to=iso(now); }

      // try endpoints; tolerant of 404/null
      const [bylineRaw, limblePayload, assetStatusCandidate] = await Promise.all([
        fetchJSON(`${ENDPOINTS.BY_LINE}?from=${from}&to=${to}`),
        fetchJSON(`${ENDPOINTS.LIMBLE_KPIASSET}?from=${from}&to=${to}`),
        loadAssetStatusCandidates()
      ]);

      const rawRows = Array.isArray(bylineRaw) ? bylineRaw : (bylineRaw && (Array.isArray(bylineRaw.rows) ? bylineRaw.rows : (Array.isArray(bylineRaw.items) ? bylineRaw.items : [])));
      const rows = (rawRows || []).map(r => {
        const machine = r.machine || r.asset || r.name || r.assetName || r.machineName || '';
        return {
          raw: r,
          machine: String(machine).trim(),
          pounds: Number(r.pounds || r.lbs || r.weight || 0) || 0,
          machineHours: Number(r.machine_hours || r.run_h || r.runtime || 0) || 0,
          maint: Number(r.maint_dt_h || r.maint_h || r.maintenance_h || 0) || 0,
          prod: Number(r.prod_dt_h || r.prod_h || 0) || 0,
          nameplate: Number(r.nameplate_lbs_hr || r.cap || 0) || 0,
          material: String(r.material || r.mat || '').toUpperCase()
        };
      });

      // filter grinding machines using alias map
      const grindingRows = rows.filter(r => r.machine && isGrindingMachine(r.machine));

      // build limble map if available
      const limbleMaintMap = {};
      if(limblePayload){
        let lp = Array.isArray(limblePayload) ? limblePayload : (Array.isArray(limblePayload.rows) ? limblePayload.rows : (Array.isArray(limblePayload.items) ? limblePayload.items : []));
        lp.forEach(it=>{
          const name = it.assetName || it.name || it.machine || it.asset || '';
          const m = Number(it.maintenance_hours || it.maint_h || it.maintenance || 0) || 0;
          if(name){ limbleMaintMap[ canonGrinding(name) ] = (limbleMaintMap[ canonGrinding(name) ] || 0) + m; }
        });
      }

      // aggregate per line
      const agg = {};
      grindingRows.forEach(r => {
        const canon = canonGrinding(r.machine);
        if(!agg[canon]) agg[canon] = { name: canon, lbs:0, mach:0, maint:0, prod:0, cap: (r.nameplate || 0), matcount:{}};
        agg[canon].lbs += r.pounds;
        agg[canon].mach += r.machineHours;
        agg[canon].maint += r.maint;
        agg[canon].prod += r.prod;
        const mat = (r.material||'').toUpperCase() || 'UNKNOWN';
        agg[canon].matcount[mat] = (agg[canon].matcount[mat]||0) + 1;
        if(r.nameplate && !agg[canon].cap) agg[canon].cap = r.nameplate;
      });

      // set a days count
      const fromD = new Date(from+'T00:00:00'), toD = new Date(to+'T00:00:00');
      let days=0; for(let d=new Date(fromD); d<=toD; d.setDate(d.getDate()+1)){ const wd=d.getDay(); if(wd!==0 && wd!==6) days++; }
      days = Math.max(1, days);

      const perLine = Object.values(agg).map(a=>{
        a.days = days;
        const plannedH = 24 * days;
        const limbleM = Number(limbleMaintMap[a.name] || 0);
        const maint = limbleM > 0 ? limbleM : (a.maint || 0);
        const runtimeH = a.mach > 0 ? a.mach : (a.cap > 0 && a.lbs>0 ? a.lbs / a.cap : 0);
        const safeRuntime = Math.max(0, Math.min(runtimeH, plannedH));
        const capPotentialDuringRuntime = a.cap > 0 ? (a.cap * safeRuntime) : 0;
        const underPerfGap = Math.max(0, Math.round(capPotentialDuringRuntime - a.lbs));
        const plannedPotential = a.cap > 0 ? (a.cap * plannedH) : 0;
        const plannedMissed = Math.max(0, Math.round(plannedPotential - a.lbs));
        const plannedMissed8 = Math.round(plannedMissed / 3);
        const perfAdj = (a.cap>0 && safeRuntime>0) ? (a.lbs / (safeRuntime * a.cap)) : 0;
        const avail = plannedH>0 ? (safeRuntime / plannedH) : 0;
        const matEntries = Object.entries(a.matcount||{}).sort((x,y)=>y[1]-x[1]);
        const domMat = matEntries.length ? matEntries[0][0] : 'N/A';
        return {...a, runtimeH: safeRuntime, perfAdj: perfAdj, avail, missed: underPerfGap, plannedMissed, plannedMissed8, dominantMaterial: domMat};
      });

      // overall totals
      const totals = perLine.reduce((s,x)=>{ s.lbs += x.lbs; s.maint += x.maint; s.runtime += x.runtimeH; s.planned += x.days*24; s.missed += x.missed; s.plannedMissed += x.plannedMissed; s.count++; return s; }, {lbs:0,maint:0,runtime:0,planned:0,missed:0,plannedMissed:0,count:0});

      const overallAvail = totals.planned ? (totals.runtime / totals.planned) : 0;
      const avgCap = perLine.length ? perLine.reduce((s,x)=>s + (x.cap||0),0)/perLine.length : 0;
      const overallPerf = (totals.runtime>0 && avgCap>0) ? (totals.lbs / (totals.runtime * avgCap)) : 0;

      $('#ov-grind-av').textContent = fmtPct(overallAvail);
      $('#ov-grind-maint').textContent = fmtH(totals.maint || 0) + ' h';
      $('#ov-grind-pr').textContent = fmtPct(overallPerf);

      // draw lines
      const linesGrid = $('#linesGrid'); linesGrid.innerHTML = '';
      perLine.sort((a,b)=> (b.perfAdj||0) - (a.perfAdj||0)).forEach(l=>{
        const div = document.createElement('div'); div.className='line';
        const left = document.createElement('div'); left.style.fontWeight='900'; left.textContent = l.name + ' • ' + l.dominantMaterial;
        const right = document.createElement('div'); right.style.textAlign='right';
        const perf = document.createElement('div'); perf.textContent = 'Perf ' + fmtPct(l.perfAdj);
        const avail = document.createElement('div'); avail.textContent = 'Avail ' + fmtPct(l.avail);
        const missed = document.createElement('div'); missed.textContent = 'Missed 8h ' + fmtNum(l.plannedMissed8);
        right.appendChild(perf); right.appendChild(avail); right.appendChild(missed);
        div.appendChild(left); div.appendChild(right);
        linesGrid.appendChild(div);
        // colorize small badges (inline style to keep the file self-contained)
        perf.style.fontWeight='900'; perf.style.color=pickColor(l.perfAdj);
        avail.style.fontWeight='900'; avail.style.color=pickColor(l.avail);
      });

      // ranking table
      const tbody = $('#rankTable tbody'); tbody.innerHTML = '';
      perLine.forEach(r=>{
        const tr = document.createElement('tr');
        const tdName = document.createElement('td'); tdName.textContent = r.name + (r.dominantMaterial ? ' • '+r.dominantMaterial : '');
        const tdPerf = document.createElement('td'); tdPerf.textContent = fmtPct(r.perfAdj);
        const tdAvail = document.createElement('td'); tdAvail.textContent = fmtPct(r.avail);
        const tdLbs = document.createElement('td'); tdLbs.textContent = fmtNum(r.lbs);
        const tdMaint = document.createElement('td'); tdMaint.textContent = fmtH(r.maint);
        const tdMiss8 = document.createElement('td'); tdMiss8.textContent = fmtNum(r.plannedMissed8);
        tr.appendChild(tdName); tr.appendChild(tdPerf); tr.appendChild(tdAvail); tr.appendChild(tdLbs); tr.appendChild(tdMaint); tr.appendChild(tdMiss8);
        tbody.appendChild(tr);
      });

      const totalTr = document.createElement('tr'); totalTr.style.fontWeight='900';
      const t1 = document.createElement('td'); t1.textContent = 'TOTAL';
      const t2 = document.createElement('td'); t2.textContent = fmtPct(perLine.length ? perLine.reduce((s,x)=>s+x.perfAdj,0)/perLine.length : 0);
      const t3 = document.createElement('td'); t3.textContent = fmtPct(overallAvail);
      const t4 = document.createElement('td'); t4.textContent = fmtNum(totals.lbs || 0);
      const t5 = document.createElement('td'); t5.textContent = fmtH(totals.maint || 0);
      const t6 = document.createElement('td'); t6.textContent = fmtNum(totals.plannedMissed || 0);
      totalTr.appendChild(t1); totalTr.appendChild(t2); totalTr.appendChild(t3); totalTr.appendChild(t4); totalTr.appendChild(t5); totalTr.appendChild(t6);
      tbody.appendChild(totalTr);

      $('#updated').textContent = new Date().toLocaleString();
    } finally {
      setLoading(false);
    }
  }

  $$('.seg button').forEach(b=>b.addEventListener('click', ()=>{ if(b.dataset.period && b.dataset.period !== STATE.period){ STATE.period = b.dataset.period; $$('.seg button').forEach(x => x.classList.toggle('active', x.dataset.period === STATE.period)); renderGrinding(); }}));
  document.addEventListener('keydown', (e)=>{ if(e.key && e.key.toLowerCase()==='f'){ if(!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{}); else document.exitFullscreen().catch(()=>{}); }});
  setInterval(()=>{ const c=$('#clock'); if(c) c.textContent = new Date().toLocaleTimeString(); },1000);
  renderGrinding();
  setInterval(()=>renderGrinding(), 10*60*1000);
  setInterval(()=>{ try{ location.reload(true); } catch(e){ location.reload(); } }, 60*60*1000);

  // Try a few candidate endpoints for live status — tolerant and returns [] if none found
  async function loadAssetStatusCandidates(){
    const list = [ENDPOINTS.PRODSTATUS, ENDPOINTS.LIMBLE_ASSETFIELDS, ENDPOINTS.LIMBLE_KPIASSET, ENDPOINTS.ASSETS_FIELDS];
    for(const url of list){
      const payload = await fetchJSON(url);
      if(!payload) continue;
      let arr = Array.isArray(payload) ? payload : (Array.isArray(payload.rows) ? payload.rows : (Array.isArray(payload.items) ? payload.items : []));
      if(!arr.length && typeof payload === 'object'){
        for(const k of Object.keys(payload)){ if(Array.isArray(payload[k]) && payload[k].length){ arr = payload[k]; break; } }
      }
      if(!arr.length) continue;
      const norm = arr.map(it=>{
        let name = it.assetName || it.name || it.AssetName || it.machine || it.asset || (it.asset && (it.asset.name||it.assetName)) || '';
        if(!name && typeof it === 'string') name = it;
        let status = it.assetStatus ?? it.status ?? it.value ?? it.state ?? it.fieldValue ?? '';
        return { source:url, raw:it, name: String(name||'').trim(), status: String(status||'').trim() };
      });
      const filtered = norm.filter(n => n.name && isGrindingMachine(n.name));
      if(filtered.length>0) return { source:url, rows: filtered };
    }
    return { source:null, rows: [] };
  }
</script>
</body>
</html>
