<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PRI Pulse – Grinding</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --pri-blue:#25408F; --pri-green:#92D050;
      --bg:#E9EDF5; --card:#FBFCFE; --ink:#0F172A; --muted:#475569; --border:#D7E0F3;
      --shadow: 0 10px 25px rgba(0,0,0,.08);
      --tile-head-fs: 30px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",Arial,sans-serif;
      font-weight:800;
      font-size:18px;
    }
    .page-production::before{
      content:"";position:fixed;inset:0;z-index:-1;
      background:
        linear-gradient(to bottom, rgba(255,255,255,.75), rgba(255,255,255,.85)),
        url('img/PRIfront.png') center/cover no-repeat fixed;
    }
    .top-border{position:fixed;top:0;left:0;width:100%;height:96px;background:var(--pri-green);z-index:10;display:flex;align-items:center;padding:0 20px}
    .top-border .logo{height:72px}
    .top-title{font-size:32px;font-weight:900;margin-left:20px;color:#0A2A12}
    .tabs{margin-left:auto;display:flex;gap:8px;align-items:center}
    .tab{background:#ffffffd9;padding:8px 12px;border-radius:10px;text-decoration:none;color:#0A2A12;font-weight:800}
    .tab.active{background:#fff}
    .wrap{margin:120px 20px 40px 20px}
    .app{max-width:1920px;margin:0 auto}
    .toolbar{display:flex;justify-content:space-between;align-items:center;margin:10px 0 16px;gap:10px;flex-wrap:wrap}
    .left,.right{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    .segBig{display:inline-flex;border:1px solid var(--border);border-radius:12px;overflow:hidden;background:var(--card);box-shadow:var(--shadow)}
    .segBig button{border:0;background:transparent;padding:10px 14px;font-weight:900;color:var(--muted);cursor:pointer;font-size:16px}
    .segBig button.active{background:var(--pri-blue);color:white}
    .pill{padding:8px 12px;border-radius:999px;background:white;border:1px solid var(--border);color:var(--muted);font-weight:900;font-size:16px}

    #loading{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(255,255,255,.55);z-index:9999}
    #loading .spinner{width:64px;height:64px;border:8px solid #e5e7eb;border-top-color:var(--pri-blue);border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    .grid{display:grid;grid-template-columns:1fr 2fr;gap:16px;align-items:start}
    @media (max-width: 1000px){ .grid{grid-template-columns:1fr} }

    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;box-shadow:var(--shadow)}
    .card h3{margin:0;padding:12px 14px;border-bottom:1px solid var(--border);font-size:var(--tile-head-fs);letter-spacing:.3px;color:var(--muted);font-weight:900}
    .card .content{padding:16px}

    .kpis{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:8px}
    .tile, .kpi{background:var(--card);padding:12px;border-radius:12px;border:1px solid var(--border);text-align:center;min-height:84px;box-shadow:var(--shadow)}
    .tile .lab,.kpi .label{font-size:14px;text-transform:uppercase;letter-spacing:.3px;color:var(--muted);font-weight:900}
    .tile .val{font-size:24px;font-weight:900;margin-top:6px}
    .tile .meta{font-size:13px;color:var(--muted);font-weight:800;margin-top:6px}

    .lines{display:grid;grid-auto-rows:minmax(80px,auto);gap:14px}
    .line{border:1px solid var(--border);border-radius:12px;padding:14px;background:white;display:flex;flex-direction:column;transition:transform .12s}
    .line:hover{transform:translateY(-4px)}
    .lineheader{display:flex;justify-content:space-between;align-items:center}
    .linename{font-weight:900;font-size:20px}
    .capright{font-size:16px;color:var(--muted);font-weight:900}
    .matBadge{font-size:14px;padding:6px 8px;border-radius:999px;background:#f1f7f2;border:1px solid #d6efdd;color:#065f2a;font-weight:900;margin-left:8px}

    .metricrow{display:grid;grid-template-columns:repeat(5,1fr);gap:8px;margin-top:10px}
    .mitem{background:#f7fafc;border:1px solid var(--border);border-radius:10px;padding:10px;min-width:0}
    .mitem .label{font-size:12px;color:var(--muted);font-weight:800}
    .mitem .mkv{font-size:20px;font-weight:900}

    #grindStatusList > div{margin-bottom:8px;padding:12px 14px;border-radius:12px;border:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;font-size:20px;background:#fff;font-weight:900;box-shadow:0 6px 18px rgba(9,30,66,.04)}
    #rankTable{width:100%;border-collapse:collapse;font-size:14px;table-layout:fixed}
    #rankTable th,#rankTable td{padding:10px;border-bottom:1px dashed var(--border)}
    #rankTable th{text-align:center;color:var(--muted);font-weight:900}
    #rankTable td.left{text-align:left}
    #rankTable td.center{text-align:center}

    .donutwrap{display:grid;grid-auto-rows:minmax(120px,auto);row-gap:18px}
    .donutrow{display:grid;grid-template-columns:220px 1fr;column-gap:18px;align-items:center}
    .donutrow canvas{width:200px !important;height:200px !important;justify-self:center}
    .legend{display:flex;flex-direction:column;gap:8px;padding-left:10px}
    .legend .item{display:flex;align-items:center;gap:10px;justify-content:flex-end}
    .bullet{width:14px;height:14px;border-radius:50%;flex:0 0 14px}
    .legend .label{font-weight:900;color:var(--muted);flex:1;text-align:left}
    .legend .val{font-weight:900;color:var(--muted);width:90px;text-align:right}

    footer{display:flex;justify-content:space-between;align-items:center;margin-top:12px;color:var(--muted);font-weight:900}
    .clock{font-variant-numeric:tabular-nums;font-weight:900}

    @media (min-width:2560px){
      .app{max-width:2560px}
      .tile .val{font-size:28px}
      #rankTable {font-size: 22px;}
    }
  </style>
</head>
<body class="page-production">
  <div id="loading"><div class="spinner" aria-hidden></div></div>

  <div class="top-border">
    <img src="img/pri-logo.png" alt="PRI Logo" class="logo" />
    <div class="top-title">PRI Pulse – Grinding <span id="periodBadge" style="font-size:14px;font-weight:700;margin-left:10px;color:#0A2A12;opacity:.95"></span></div>
    <div class="tabs">
      <a class="tab" href="index.html">Work Orders</a>
      <a class="tab" href="prodstatus.html">Prod Status</a>
      <a class="tab" href="kpi-by-asset.html">KPIs by Asset</a>
      <a class="tab" href="production.html">PACE</a>
      <a class="tab" href="pulse.html">Pulse</a>
      <a class="tab active" href="grinding.html">Grinding</a>
      <a class="tab" href="admin">Admin</a>
      <img src="img/innovation-logo.png" alt="Innovation" style="height:56px;margin-left:8px;object-fit:contain"/>
    </div>
  </div>

  <div class="wrap">
    <div class="app">
      <div class="toolbar">
        <div class="left">
          <div class="segBig" id="tfButtons" role="tablist" aria-label="Timeframe">
            <button data-period="today" class="active">Today</button>
            <button data-period="yesterday">Yesterday</button>
            <button data-period="week">This Week</button>
            <button data-period="lastweek">Last Week</button>
            <button data-period="month">This Month</button>
            <button data-period="lastmonth">Last Month</button>
            <button data-period="r7">Rolling 7d</button>
            <button data-period="r30">Rolling 30d</button>
          </div>
          <span class="pill" style="font-size:14px">Grinding Lines Only</span>
        </div>
        <div class="right">
          <span class="pill" style="font-size:14px">Auto-refresh: <strong id="refreshSec">600s</strong></span>
          <span class="pill" style="font-size:14px">Press <strong>F</strong> for Fullscreen</span>
        </div>
      </div>

      <section class="card" style="margin-bottom:16px">
        <h3>Grinding – Overall KPIs</h3>
        <div class="content">
          <div style="font-size:12px;color:var(--muted);margin-bottom:8px">Range: <span id="rangeLabel">—</span></div>
          <div class="kpis">
            <div id="tile-grind-av" class="tile">
              <div class="lab">Grinding Availability</div>
              <div class="val" id="ov-grind-av">0%</div>
              <div class="meta" id="ov-grind-av-sub"></div>
            </div>
            <div id="tile-maint-dt" class="tile">
              <div class="lab">Maintenance Downtime</div>
              <div class="val" id="ov-maint-dt">0%</div>
              <div class="meta" id="ov-maint-dt-sub"></div>
            </div>
            <div id="tile-performance" class="tile">
              <div class="lab">Performance</div>
              <div class="val" id="ov-pr">0%</div>
              <div class="meta" id="ov-pr-sub"></div>
            </div>
          </div>
        </div>
      </section>

      <div class="grid" style="margin-bottom:16px">
        <article class="card">
          <h3 style="font-size:20px">LIVE Line Status — Grinding</h3>
          <div class="content">
            <div id="grindStatusList" style="min-height:120px"></div>
            <div style="margin-top:8px;font-size:12px;color:var(--muted)">Status filtered to grinding lines only.</div>
          </div>
        </article>

        <article class="card">
          <h3 style="font-size:20px">Line Health — Availability & Performance</h3>
          <div class="content">
            <div id="linesGrid" class="lines"></div>
          </div>
        </article>
      </div>

      <div class="grid">
        <article class="card">
          <h3>Downtime Overview — Grinding & Maintenance</h3>
          <div class="content">
            <div class="donutwrap">
              <div class="donutrow">
                <canvas id="donutProd" width="220" height="220"></canvas>
                <div class="legend" id="legendProd"></div>
              </div>
              <div class="donutrow">
                <canvas id="donutMaintCat" width="220" height="220"></canvas>
                <div class="legend" id="legendMaintCat"></div>
              </div>
              <div class="donutrow">
                <canvas id="donutMaintMode" width="220" height="220"></canvas>
                <div class="legend" id="legendMaintMode"></div>
              </div>
            </div>
            <div style="margin-top:12px;font-size:12px;color:var(--muted)">Charts show the top reasons/categories/modes for the selected range (grinding assets only).</div>
          </div>
        </article>

        <article class="card">
          <h3>Lines Ranked by Performance & Missed Opportunity</h3>
          <div class="content">
            <table id="rankTable">
              <thead>
                <tr><th style="width:30%">Line</th><th>Perf %</th><th>Avail %</th><th>Pounds</th><th>Missed Opp (lb)</th></tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </article>
      </div>

      <footer>
        <div>Last updated <span id="updated">—</span></div>
        <div class="clock" id="clock"></div>
      </footer>
    </div>
  </div>

<script>
  const ENDPOINTS = {
    BY_LINE:'/api/production/by-line',
    PRODSTATUS:'/api/workorders/prodstatus',
    LIMBLE_ASSETFIELDS:'/api/limble/assetfields',
    LIMBLE_KPIASSET:'/api/limble/kpiassetfields',
    ASSETS_FIELDS:'/api/assets/fields',
    MAP:'mappings.json'
  };

  const COLOR_CONFIG = {
    overall: {
      thresholds: { good: 0.85, warn: 0.7 },
      hex: { good: '#10B981', warn: '#FBBF24', bad: '#EF4444' }
    },
    status: {
      available: '#10B981',
      other: '#FBBF24'
    },
    lineHealth: {
      thresholds: { good: 0.80, warn: 0.60 },
      hex: { good: '#10B981', warn: '#FBBF24', bad: '#EF4444' }
    }
  };

  const STATE = { period:'today' };
  const $ = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));

  function setLoading(v){ const el=$('#loading'); if(el) el.style.display = v ? 'flex' : 'none'; }
  async function fetchJSON(url, opts = {}) {
    try {
      const sep = url.includes('?') ? '&' : '?';
      const r = await fetch(url + sep + 'ts=' + Date.now(), opts);
      if (!r.ok) throw new Error('HTTP ' + r.status);
      return await r.json();
    } catch (e) { console.warn('fetchJSON fail', url, e); return null; }
  }
  function fmtPct(v){ return Number.isFinite(v) ? (Math.round(v*100)+'%') : '0%'; }
  function fmtNum(n){ return Number.isFinite(n) ? Math.round(n).toLocaleString() : '0'; }
  function fmtH(v){ return Number.isFinite(v) ? v.toFixed(1) : '0.0'; }

  function pickColorForPct(frac, type='lineHealth'){
    const cfg = (type === 'overall') ? COLOR_CONFIG.overall : COLOR_CONFIG.lineHealth;
    const thr = cfg.thresholds;
    if(frac >= thr.good) return cfg.hex.good;
    if(frac >= thr.warn) return cfg.hex.warn;
    return cfg.hex.bad;
  }

  function machineNameFromRow(r){ if(!r) return ''; return String(r.machine || r.asset || r.name || r.assetName || r.AssetName || r.machineName || r.device || r.Asset || '').trim(); }
  function poundsFromRow(r){ return Number(r.pounds ?? r.lbs ?? r.weight ?? r.total_lbs ?? r.pounds_total ?? 0) || 0; }
  function machineHoursFromRow(r){ return Number(r.machine_hours ?? r.run_h ?? r.runHours ?? r.runtime_h ?? r.run_time ?? 0) || 0; }
  function maintFromRow(r){ return Number(r.maint_dt_h ?? r.maint_h ?? r.maintenance_h ?? r.maintenance_hours ?? 0) || 0; }
  function prodDTFromRow(r){ return Number(r.prod_dt_h ?? r.prod_h ?? r.prod_dt ?? 0) || 0; }
  function nameplateFromRow(r){ return Number(r.nameplate_lbs_hr ?? r.nameplate ?? r.cap ?? r.cap_lbs_hr ?? 0) || 0; }
  function materialFromRow(r){ return String(r.material || r.mat || r.resin || '').toUpperCase(); }

  let MAPPINGS = null;
  async function loadMappings(){ if(MAPPINGS) return MAPPINGS; try { const j = await fetchJSON(ENDPOINTS.MAP); MAPPINGS = j || {}; } catch(e){ MAPPINGS = {}; } return MAPPINGS; }

  function capacityFor(lineName, material){
    const caps = MAPPINGS?.capacities_lbs_hr || {}, byMat = MAPPINGS?.capacity_by_material_lbs_hr || {}, alias = MAPPINGS?.capacity_aliases || {}, malias = MAPPINGS?.material_aliases || {};
    const canon = (caps[lineName] !== undefined || byMat[lineName]) ? lineName : (alias[lineName] || lineName);
    const m = malias[(material||'').toUpperCase()] || ((material||'')===''?'DEFAULT':(material||'').toUpperCase());
    return (byMat[canon]?.[m]) ?? (byMat[canon]?.DEFAULT) ?? caps[canon] ?? 0;
  }

  const GRIND_CANON = [
    {canon:'Shredder 1', aliases:['Shredder 1','Shredding Line 1','Shredding 1']},
    {canon:'Shredder 3', aliases:['Shredder 3','Shredding Line 3','Shredding 3']},
    {canon:'Shredder 5', aliases:['Shredder 5','Shredding Line 5','Shredding 5']},
    {canon:'Weima', aliases:['Weima','Shredding Line 6- WEIMA','Shredding Line 6 - WEIMA']},
    {canon:'Vistakon 1', aliases:['Vistakon 1','Grinder V1','Vistakon 1']},
    {canon:'Vistakon 2', aliases:['Vistakon 2','Grinder V2','Vistakon 2']},
    {canon:'PCR Washline', aliases:['PCR Washline','PCR','PCR Wash Line']}
  ];
  const GRIND_ALIAS_REV = (() => { const m = new Map(); for(const r of GRIND_CANON){ m.set(r.canon, r.canon); (r.aliases||[]).forEach(a=>m.set(String(a).trim(), r.canon)); } return m; })();
  const GRIND_CANON_SET = new Set(GRIND_CANON.map(r=>r.canon));
  function canonGrinding(n){ return GRIND_ALIAS_REV.get(String(n||'').trim()) || String(n||'').trim(); }
  function isGrindingMachine(n){ return GRIND_CANON_SET.has(canonGrinding(n)); }

  function drawDonutSegments(canvas, segments){
    if(!canvas) return;
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);
    const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 10, inner = r*0.55;
    const total = segments.reduce((s,x)=>s + (x.value||0),0) || 1;
    let start = -Math.PI/2;
    for(const seg of segments){
      const ang = (seg.value/total) * Math.PI * 2;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,r,start,start+ang,false);
      ctx.arc(cx,cy,inner,start+ang,start,true);
      ctx.closePath();
      ctx.fillStyle = seg.color;
      ctx.fill();
      start += ang;
    }
    ctx.fillStyle = '#0b1722';
    ctx.font = '800 18px system-ui';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    const pct = Math.round((segments[0]?.value||0) / total * 100);
    ctx.fillText(pct + '%', cx, cy);
  }

  async function loadAssetStatusCandidates(){
    const candidates = [ENDPOINTS.PRODSTATUS, ENDPOINTS.LIMBLE_ASSETFIELDS, ENDPOINTS.LIMBLE_KPIASSET, ENDPOINTS.ASSETS_FIELDS];
    for(const url of candidates){
      const payload = await fetchJSON(url);
      if(!payload) continue;
      let arr = Array.isArray(payload) ? payload : (Array.isArray(payload.rows) ? payload.rows : (Array.isArray(payload.items) ? payload.items : []));
      if(!arr.length && typeof payload==='object'){
        for(const p of Object.keys(payload)){
          if(Array.isArray(payload[p]) && payload[p].length>0){ arr = payload[p]; break; }
          if(typeof payload[p] === 'string' && payload[p].trim().startsWith('[')){
            try{ arr = JSON.parse(payload[p]); break; } catch(e){}
          }
        }
      }
      if(!arr.length) continue;
      const norm = arr.map(it=>{
        let name = it.assetName || it.name || it.AssetName || it.machine || it.asset || (it.asset && (it.asset.name || it.assetName)) || '';
        if(!name && typeof it === 'string') name = it;
        let status = it.assetStatus ?? it.status ?? it.value ?? it.state ?? it.fieldValue ?? '';
        if(status && typeof status === 'object'){ status = status.text ?? status.name ?? status.value ?? JSON.stringify(status); }
        return { source:url, raw:it, name: String(name||'').trim(), status: String(status||'').trim() };
      });
      const filtered = norm.filter(n => n.name && isGrindingMachine(n.name));
      if(filtered.length>0) return { source:url, rows: filtered };
    }
    return { source:null, rows: [] };
  }

  function renderListBar(container, list){
    container.innerHTML = '';
    const top = list.slice(0,6);
    const max = top.reduce((m,x)=>Math.max(m,x.value||0),0) || 1;
    top.forEach(it=>{
      const row = document.createElement('div');
      row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px'; row.style.marginBottom='6px';
      const label = document.createElement('div'); label.style.flex='1'; label.textContent = it.key; label.style.fontWeight='900'; label.style.fontSize='14px';
      const barwrap = document.createElement('div'); barwrap.style.flex='1';
      const bar = document.createElement('div'); bar.style.height='12px'; bar.style.borderRadius='8px'; bar.style.background='#eef6f0'; bar.style.overflow='hidden';
      const inner = document.createElement('div'); inner.style.width = Math.round((it.value/max)*100)+'%'; inner.style.height='100%'; inner.style.background='linear-gradient(90deg,#0AAC00,#42C36A)';
      const val = document.createElement('div'); val.style.width='80px'; val.style.textAlign='right'; val.textContent = fmtH(it.value);
      bar.appendChild(inner); barwrap.appendChild(bar);
      row.appendChild(label); row.appendChild(barwrap); row.appendChild(val);
      container.appendChild(row);
    });
  }

  function makeLegend(containerEl, arr, colors){
    containerEl.innerHTML = '';
    const total = arr.reduce((s,x)=>s + (x.value||0),0) || 1;
    arr.slice(0,5).forEach((it,i)=>{
      const row = document.createElement('div'); row.className='item';
      const bullet = document.createElement('div'); bullet.className='bullet'; bullet.style.background = colors[i] || '#ddd';
      const label = document.createElement('div'); label.className='label'; label.textContent = it.key;
      const val = document.createElement('div'); val.className='val'; val.textContent = fmtH(it.value) + ' h';
      const pct = document.createElement('div'); pct.style.width='50px'; pct.style.textAlign='right'; pct.style.color='var(--muted)'; pct.style.fontWeight='800'; pct.textContent = Math.round((it.value/total)*100) + '%';
      row.appendChild(bullet); row.appendChild(label); row.appendChild(val); row.appendChild(pct);
      containerEl.appendChild(row);
    });
  }

  function applyTileBg(tileId, pct, valText, metaText){
    const tile = document.getElementById(tileId);
    if(!tile) return;
    const bg = pickColorForPct(pct, 'overall');
    tile.style.background = bg;
    tile.style.borderColor = bg;
    tile.style.color = '#ffffff';
    const lab = tile.querySelector('.lab'); if(lab) lab.style.color = 'rgba(255,255,255,0.95)';
    const val = tile.querySelector('.val'); if(val){ val.textContent = valText; val.style.color = '#ffffff'; }
    const meta = tile.querySelector('.meta'); if(meta){ meta.textContent = metaText || ''; meta.style.color = 'rgba(255,255,255,0.9)'; }
    tile.style.boxShadow = '0 10px 25px rgba(0,0,0,0.12)';
  }

  function applyMItemBg(mitemEl, color){
    if(!mitemEl) return;
    mitemEl.style.background = color;
    mitemEl.style.borderColor = color;
    mitemEl.style.color = '#ffffff';
    const lbl = mitemEl.querySelector('.label'); if(lbl) lbl.style.color = 'rgba(255,255,255,0.95)';
    const mkv = mitemEl.querySelector('.mkv'); if(mkv) mkv.style.color = '#ffffff';
    mitemEl.style.boxShadow = '0 8px 18px rgba(0,0,0,0.12)';
  }

  async function renderGrinding(){
    setLoading(true);
    try{
      await loadMappings();
      const periodBadge = $('#periodBadge'); if(periodBadge) periodBadge.textContent = '• ' + (STATE.period || 'today');
      $$('.segBig button').forEach(b=>b.classList.toggle('active', b.dataset.period===STATE.period));
      const now = new Date(); now.setHours(0,0,0,0);
      function iso(d){ return new Date(d.getTime()-d.getTimezoneOffset()*60000).toISOString().slice(0,10); }
      let from,to;
      switch(STATE.period){
        case 'yesterday': { const y=new Date(now); y.setDate(y.getDate()-1); from=to=iso(y); break; }
        case 'week': { const d=new Date(now); const day=(d.getDay()+6)%7; d.setDate(d.getDate()-day); from=iso(d); const e=new Date(d); e.setDate(e.getDate()+6); to=iso(e); break; }
        case 'lastweek': { const d=new Date(now); const day=(d.getDay()+6)%7; d.setDate(d.getDate()-day-7); from=iso(d); const e=new Date(d); e.setDate(e.getDate()+6); to=iso(e); break; }
        case 'month': { const s=new Date(now.getFullYear(),now.getMonth(),1); from=iso(s); const e=new Date(now.getFullYear(),now.getMonth()+1,0); to=iso(e); break; }
        case 'lastmonth': { const s=new Date(now.getFullYear(),now.getMonth()-1,1); from=iso(s); const e=new Date(now.getFullYear(),now.getMonth(),0); to=iso(e); break; }
        case 'r7': { const s=new Date(now); s.setDate(s.getDate()-6); from=iso(s); to=iso(now); break; }
        case 'r30': default: { const s=new Date(now); s.setDate(s.getDate()-29); from=iso(s); to=iso(now); break; }
      }
      const rangeLabel = $('#rangeLabel'); if(rangeLabel) rangeLabel.textContent = (from && to) ? (from + ' → ' + to) : '—';

      // fetch
      const [bylineRaw, limblePayload, assetStatusCandidate] = await Promise.all([
        fetchJSON(ENDPOINTS.BY_LINE + '?from=' + (from||'') + '&to=' + (to||'')),
        fetchJSON(ENDPOINTS.LIMBLE_KPIASSET + '?from=' + (from||'') + '&to=' + (to||'')),
        loadAssetStatusCandidates()
      ]);

      const rawRows = Array.isArray(bylineRaw) ? bylineRaw : (bylineRaw && (Array.isArray(bylineRaw.rows) ? bylineRaw.rows : (Array.isArray(bylineRaw.items) ? bylineRaw.items : [])));
      const parsed = (rawRows||[]).map(r=>{
        return {
          raw:r,
          machine: machineNameFromRow(r),
          pounds: poundsFromRow(r),
          machineHours: machineHoursFromRow(r),
          maint: maintFromRow(r),
          prod: prodDTFromRow(r),
          nameplate: nameplateFromRow(r),
          material: materialFromRow(r)
        };
      });
      const grindingRows = parsed.filter(p=>p.machine && isGrindingMachine(p.machine));

      // parse limble payload into maint map
      const limbleMaintMap = {};
      if(limblePayload){
        let lp = Array.isArray(limblePayload) ? limblePayload : (Array.isArray(limblePayload.rows) ? limblePayload.rows : (Array.isArray(limblePayload.items) ? limblePayload.items : []));
        if(!lp.length && typeof limblePayload === 'object'){
          for(const k of Object.keys(limblePayload)){
            if(Array.isArray(limblePayload[k]) && limblePayload[k].length){ lp = limblePayload[k]; break; }
          }
        }
        if(Array.isArray(lp)){
          lp.forEach(it=>{
            const name = machineNameFromRow(it) || machineNameFromRow(it.raw || it);
            const m = Number(it.maintenance_hours ?? it.maint_hours ?? it.maint_h ?? it.maintenance_h ?? it.maintenance ?? it.total_maintenance_hours ?? it.maint || 0) || 0;
            if(name) limbleMaintMap[canonGrinding(name)] = (limbleMaintMap[canonGrinding(name)] || 0) + m;
          });
        }
      }

      // aggregate by canonical name
      const agg = {};
      grindingRows.forEach(r=>{
        const canon = canonGrinding(r.machine);
        const capFromMap = capacityFor(canon, r.material);
        const cap = r.nameplate > 0 ? r.nameplate : (capFromMap || 0);
        if(!agg[canon]) agg[canon] = { name:canon, lbs:0, maint:0, prod:0, mach:0, cap:cap, days:1, matcount:{} };
        agg[canon].lbs += Math.max(0, r.pounds);
        agg[canon].prod += Math.max(0, r.prod);
        agg[canon].mach += Math.max(0, r.machineHours);
        agg[canon].maint += Math.max(0, r.maint);
        const m = (r.material || 'UNKNOWN').toUpperCase();
        agg[canon].matcount[m] = (agg[canon].matcount[m]||0) + 1;
        if(cap>0) agg[canon].cap = cap;
      });

      // days (count weekdays)
      const fromD = new Date((from||'') + 'T00:00:00'), toD = new Date((to||'') + 'T00:00:00');
      let days = 0;
      for(let d = new Date(fromD); d <= toD; d.setDate(d.getDate()+1)){
        const wd = d.getDay();
        if(wd !== 0 && wd !== 6) days++;
      }
      days = Math.max(1, days);
      Object.values(agg).forEach(a=>a.days = days);

      // compute perLine
      const perLine = Object.values(agg).map(a=>{
        const matEntries = Object.entries(a.matcount || {});
        const domMat = matEntries.length ? matEntries.sort((x,y)=>y[1]-x[1])[0][0] : 'N/A';
        const plannedH = 24 * a.days;
        const limbleMaint = limbleMaintMap[a.name];
        const maint = (typeof limbleMaint === 'number' && limbleMaint > 0) ? limbleMaint : a.maint;
        let runtimeH = a.mach > 0 ? a.mach : (a.cap > 0 ? (a.lbs / a.cap) : 0);
        runtimeH = Math.max(0, Math.min(runtimeH, plannedH));
        const grindDowntime = Math.max(0, plannedH - runtimeH - (maint || 0));
        let perfAdj = 0;
        if(a.cap > 0 && runtimeH > 0) perfAdj = a.lbs / (runtimeH * a.cap);
        perfAdj = Math.max(0, Math.min(perfAdj, 10));
        const capPotential = a.cap > 0 ? (a.cap * runtimeH) : 0;
        const missed = Math.max(0, Math.round(capPotential - a.lbs));
        const avail = plannedH > 0 ? (runtimeH / plannedH) : 0;
        return Object.assign({}, a, { plannedH, runtimeH, maint, grindDowntime, perfAdj, oee: (runtimeH>0 ? (runtimeH/plannedH) * perfAdj : 0), capPotential, missed, dominantMaterial: domMat, avail });
      });

      // totals
      const totals = perLine.reduce((s,x)=>{
        s.lbs += x.lbs; s.maint += (x.maint||0); s.runtime += (x.runtimeH||0); s.planned += x.plannedH;
        s.missed += x.missed||0; s.caps += (x.cap||0); s.prod += (x.prod||0); s.count++;
        return s;
      }, {lbs:0,maint:0,runtime:0,planned:0,missed:0,caps:0,prod:0,count:0});

      const overallAvail = totals.planned>0 ? (totals.runtime / totals.planned) : 0;
      const avgCap = totals.count ? (totals.caps / totals.count) : 0;
      const overallPerfAdj = (totals.runtime>0 && avgCap>0) ? (totals.lbs / (totals.runtime * avgCap)) : 0;

      applyTileBg('tile-grind-av', overallAvail, fmtPct(overallAvail), fmtNum(Math.round(totals.runtime)) + ' run h • ' + fmtNum(Math.round(totals.planned)) + ' planned h');
      const maintFrac = totals.planned ? (totals.maint / totals.planned) : 0;
      applyTileBg('tile-maint-dt', maintFrac, fmtPct(maintFrac), fmtH(totals.maint) + ' maint h • ' + fmtH(totals.prod) + ' prod dt h');
      applyTileBg('tile-performance', overallPerfAdj, fmtPct(overallPerfAdj), fmtNum(Math.round(totals.lbs)) + ' lbs • avg cap ' + fmtNum(Math.round(avgCap)) + ' lbs/hr');

      // donuts (simple seeds)
      const prodReasonsMap = {}; const maintCatsMap = {}; const maintModesMap = {};
      (rawRows||[]).forEach(r=>{
        const rReason = r.reason || r.downtimeReason || r.dt_reason || r.DowntimeReason || r.prod_reason || '';
        const rCat = r.maintenanceCategory || r.category || r.maint_category || r.maint_cat || '';
        const rMode = r.failureMode || r.mode || r.failure_mode || '';
        if(rReason) prodReasonsMap[rReason] = (prodReasonsMap[rReason]||0) + (r.prod_dt_h || r.prod_h || 1);
        if(rCat) maintCatsMap[rCat] = (maintCatsMap[rCat]||0) + (r.maint_dt_h || r.maint_h || 1);
        if(rMode) maintModesMap[rMode] = (maintModesMap[rMode]||0) + (r.maint_dt_h || r.maint_h || 1);
      });
      const prodReasonsArr = Object.keys(prodReasonsMap).map(k=>({key:k,value:prodReasonsMap[k]})).sort((a,b)=>b.value-a.value);
      const maintCatsArr = Object.keys(maintCatsMap).map(k=>({key:k,value:maintCatsMap[k]})).sort((a,b)=>b.value-a.value);
      const maintModesArr = Object.keys(maintModesMap).map(k=>({key:k,value:maintModesMap[k]})).sort((a,b)=>b.value-a.value);

      const prodSeed = prodReasonsArr.length ? prodReasonsArr : [{key:'UNSTATED',value: (totals.prod || 0) || 1}];
      const mcatSeed = maintCatsArr.length ? maintCatsArr : [{key:'Other',value:1}];
      const mmodeSeed = maintModesArr.length ? maintModesArr : [{key:'Machine Damaged',value:1}];

      const prodColors = ['#4b5563', COLOR_CONFIG.overall.hex.good, '#d1d5db', '#1e40af', COLOR_CONFIG.overall.hex.warn];
      const catColors = ['#1f2937','#d1d5db',COLOR_CONFIG.overall.hex.good,COLOR_CONFIG.overall.hex.bad];
      const modeColors = ['#071332','#ef6b2f','#1e40af','#94a3b8'];

      const segProd = prodSeed.slice(0,6).map((it,i)=>({ value: it.value, color: prodColors[i] || '#ccc', key: it.key }));
      const segCat = mcatSeed.slice(0,6).map((it,i)=>({ value: it.value, color: catColors[i] || '#ccc', key: it.key }));
      const segMode = mmodeSeed.slice(0,6).map((it,i)=>({ value: it.value, color: modeColors[i] || '#ccc', key: it.key }));

      drawDonutSegments($('#donutProd'), segProd);
      makeLegend($('#legendProd'), prodSeed, prodColors);
      drawDonutSegments($('#donutMaintCat'), segCat);
      makeLegend($('#legendMaintCat'), mcatSeed, catColors);
      drawDonutSegments($('#donutMaintMode'), segMode);
      makeLegend($('#legendMaintMode'), mmodeSeed, modeColors);

      // render lines using DOM methods (avoid nested template pitfalls)
      const linesGrid = $('#linesGrid'); if(linesGrid) linesGrid.innerHTML = '';
      perLine.sort((a,b)=> (b.perfAdj||0) - (a.perfAdj||0)).forEach(l=>{
        const card = document.createElement('div'); card.className = 'line';
        // header
        const h = document.createElement('div'); h.className = 'lineheader';
        const left = document.createElement('div'); left.style.display = 'flex'; left.style.gap = '12px'; left.style.alignItems = 'center';
        const nm = document.createElement('div'); nm.className = 'linename'; nm.textContent = l.name;
        const mat = document.createElement('div'); mat.style.fontWeight = '900'; mat.style.color = 'var(--muted)'; mat.textContent = l.dominantMaterial || '';
        const cap = document.createElement('div'); cap.style.fontWeight = '900'; cap.style.color = 'var(--muted)'; cap.textContent = (l.cap && l.cap>0) ? (fmtNum(l.cap) + ' lbs/hr') : 'cap unknown';
        const lbs = document.createElement('div'); lbs.style.fontWeight = '900'; lbs.style.color = 'var(--muted)'; lbs.textContent = fmtNum(l.lbs) + ' lb';
        left.appendChild(nm); left.appendChild(mat); left.appendChild(cap); left.appendChild(lbs);
        const right = document.createElement('div'); right.className = 'capright'; right.style.fontSize = '18px'; right.textContent = Math.round((l.perfAdj||0)*100) + '%';
        h.appendChild(left); h.appendChild(right);
        card.appendChild(h);

        // metrics row
        const mr = document.createElement('div'); mr.className = 'metricrow';
        const fields = [
          {label:'Maint h', value: fmtH(l.maint)},
          {label:'Grind DT h', value: fmtH(l.grindDowntime)},
          {label:'Runtime h', value: fmtH(l.runtimeH)},
          {label:'Availability', value: fmtPct(l.avail)},
          {label:'Perf Adj', value: fmtPct(l.perfAdj)}
        ];
        fields.forEach(f=>{
          const mi = document.createElement('div'); mi.className = 'mitem';
          const lab = document.createElement('div'); lab.className = 'label'; lab.textContent = f.label;
          const mkv = document.createElement('div'); mkv.className = 'mkv'; mkv.textContent = f.value;
          if(f.label === 'Availability') mkv.setAttribute('data-avail', String(l.avail));
          if(f.label === 'Perf Adj') mkv.setAttribute('data-perf', String(l.perfAdj));
          mi.appendChild(lab); mi.appendChild(mkv);
          mr.appendChild(mi);
        });
        card.appendChild(mr);
        linesGrid.appendChild(card);

        // apply colours
        const availColor = pickColorForPct(l.avail, 'lineHealth');
        const perfColor = pickColorForPct(l.perfAdj, 'lineHealth');
        const availM = card.querySelector('.mkv[data-avail]')?.closest('.mitem');
        const perfM = card.querySelector('.mkv[data-perf]')?.closest('.mitem');
        if(availM) applyMItemBg(availM, availColor);
        if(perfM) applyMItemBg(perfM, perfColor);
      });

      // rank table
      const tbody = $('#rankTable tbody'); if(tbody) tbody.innerHTML = '';
      perLine.sort((a,b) => ((b.perfAdj||0) - (a.perfAdj||0)) || ((b.avail||0) - (a.avail||0)));
      perLine.forEach(r=>{
        const tr = document.createElement('tr');
        const td1 = document.createElement('td'); td1.className = 'left';
        const nameDiv = document.createElement('div'); nameDiv.textContent = r.name;
        const small = document.createElement('div'); small.style.fontSize='12px'; small.style.color='var(--muted)'; small.style.fontWeight='800'; small.textContent = r.dominantMaterial || '';
        td1.appendChild(nameDiv); td1.appendChild(small);
        const td2 = document.createElement('td'); td2.className='center'; td2.textContent = fmtPct(r.perfAdj);
        const td3 = document.createElement('td'); td3.className='center'; td3.textContent = fmtPct(r.avail);
        const td4 = document.createElement('td'); td4.className='center'; td4.textContent = fmtNum(r.lbs);
        const td5 = document.createElement('td'); td5.className='center'; td5.textContent = fmtNum(r.missed);
        tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3); tr.appendChild(td4); tr.appendChild(td5);
        tbody.appendChild(tr);
      });

      // total row
      if(tbody){
        const totalTr = document.createElement('tr'); totalTr.style.fontWeight='900';
        const td1 = document.createElement('td'); td1.className='left'; td1.textContent = 'TOTAL';
        const avgPerf = perLine.length ? (perLine.reduce((s,x)=>s + (x.perfAdj||0),0) / perLine.length) : 0;
        const td2 = document.createElement('td'); td2.className='center'; td2.textContent = fmtPct(avgPerf);
        const td3 = document.createElement('td'); td3.className='center'; td3.textContent = fmtPct(overallAvail);
        const td4 = document.createElement('td'); td4.className='center'; td4.textContent = fmtNum(totals.lbs);
        const td5 = document.createElement('td'); td5.className='center'; td5.textContent = fmtNum(totals.missed);
        totalTr.appendChild(td1); totalTr.appendChild(td2); totalTr.appendChild(td3); totalTr.appendChild(td4); totalTr.appendChild(td5);
        tbody.appendChild(totalTr);
      }

      // live status list
      const statusEl = $('#grindStatusList'); if(statusEl) statusEl.innerHTML = '';
      const statuses = (assetStatusCandidate && assetStatusCandidate.rows) ? assetStatusCandidate.rows : [];
      statuses.sort((a,b)=> canonGrinding(a.name).localeCompare(canonGrinding(b.name)));
      if(statuses.length === 0){
        const msg = document.createElement('div'); msg.style.color='var(--muted)'; msg.style.fontWeight='900'; msg.textContent = 'No live status found for grinding assets from the attempted endpoints.';
        statusEl.appendChild(msg);
      } else {
        statuses.forEach(S=>{
          const row = document.createElement('div');
          row.style.display = 'flex'; row.style.justifyContent = 'space-between'; row.style.alignItems = 'center'; row.style.fontSize='18px';
          const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center';
          const name = document.createElement('strong'); name.style.fontSize='18px'; name.textContent = canonGrinding(S.name);
          left.appendChild(name);
          const statusRight = document.createElement('div'); statusRight.style.fontSize='18px'; statusRight.style.color='var(--muted)'; statusRight.style.fontWeight='800';
          const st = S.status || (S.raw && (S.raw.assetStatus || S.raw.status || S.raw.value || '')) || 'Available';
          const stLower = String(st||'').toLowerCase();
          const isAvailable = stLower.includes('avail') || stLower.includes('available') || stLower.includes('ready') || stLower.includes('in production');
          const color = isAvailable ? COLOR_CONFIG.status.available : COLOR_CONFIG.status.other;
          const bullet = document.createElement('span'); bullet.style.display='inline-block'; bullet.style.width='12px'; bullet.style.height='12px'; bullet.style.borderRadius='50%'; bullet.style.background = color; bullet.style.marginLeft='10px';
          statusRight.textContent = st;
          statusRight.appendChild(bullet);
          row.appendChild(left); row.appendChild(statusRight);
          statusEl.appendChild(row);
        });
      }

      const updated = $('#updated'); if(updated) updated.textContent = (new Date()).toLocaleString();
    } finally {
      setLoading(false);
    }
  }

  // wire timeframe buttons
  document.addEventListener('click', function(e){
    const btn = e.target.closest('.segBig button');
    if (btn?.dataset?.period && btn.dataset.period !== STATE.period) {
      STATE.period = btn.dataset.period;
      renderGrinding();
    }
  });

  document.addEventListener('keydown', (e)=>{
    if (e.key && e.key.toLowerCase && e.key.toLowerCase() === 'f') {
      if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{});
      else document.exitFullscreen().catch(()=>{});
    }
  });

  setInterval(()=>{ const c=$('#clock'); if(c) c.textContent = (new Date()).toLocaleTimeString(); },1000);

  // initial render + auto-refresh
  renderGrinding();
  setInterval(() => { renderGrinding(); }, 10 * 60 * 1000);

  document.addEventListener('DOMContentLoaded', () => {
    $$('.segBig button').forEach(b => b.classList.toggle('active', b.dataset.period === STATE.period));
  });
</script>
</body>
</html>
